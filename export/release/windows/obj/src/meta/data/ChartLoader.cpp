// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_ForeverAssets
#include <ForeverAssets.h>
#endif
#ifndef INCLUDED_Init
#include <Init.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_gameObjects_userInterface_notes_Note
#include <gameObjects/userInterface/notes/Note.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_meta_MusicBeatState
#include <meta/MusicBeatState.h>
#endif
#ifndef INCLUDED_meta_data_ChartLoader
#include <meta/data/ChartLoader.h>
#endif
#ifndef INCLUDED_meta_data_Conductor
#include <meta/data/Conductor.h>
#endif
#ifndef INCLUDED_meta_data_dependency_FNFSprite
#include <meta/data/dependency/FNFSprite.h>
#endif
#ifndef INCLUDED_meta_data_dependency_FNFUIState
#include <meta/data/dependency/FNFUIState.h>
#endif
#ifndef INCLUDED_meta_state_PlayState
#include <meta/state/PlayState.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_c6a693c36ae6dc27_24_generateChartType,"meta.data.ChartLoader","generateChartType",0x2496654b,"meta.data.ChartLoader.generateChartType","meta/data/ChartLoader.hx",24,0xeb7635e8)
namespace meta{
namespace data{

void ChartLoader_obj::__construct() { }

Dynamic ChartLoader_obj::__CreateEmpty() { return new ChartLoader_obj; }

void *ChartLoader_obj::_hx_vtable = 0;

Dynamic ChartLoader_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ChartLoader_obj > _hx_result = new ChartLoader_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ChartLoader_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x73a64722;
}

::Array< ::Dynamic> ChartLoader_obj::generateChartType( ::Dynamic songData,::String __o_typeOfChart){
            		::String typeOfChart = __o_typeOfChart;
            		if (::hx::IsNull(__o_typeOfChart)) typeOfChart = HX_("FNF",fe,61,35,00);
            	HX_STACKFRAME(&_hx_pos_c6a693c36ae6dc27_24_generateChartType)
HXLINE(  25)		::Array< ::Dynamic> unspawnNotes = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  26)		::Array< ::Dynamic> noteData = ( (::Array< ::Dynamic>)(songData->__Field(HX_("notes",41,dc,ca,9f),::hx::paccDynamic)) );
HXLINE(  29)		if (::hx::IsNull( typeOfChart )) {
HXLINE(  33)			int daBeats = 0;
HXLINE(  35)			{
HXLINE(  35)				int _g = 0;
HXDLIN(  35)				while((_g < noteData->length)){
HXLINE(  35)					 ::Dynamic section = noteData->__get(_g);
HXDLIN(  35)					_g = (_g + 1);
HXLINE(  36)					int coolSection = ::Std_obj::_hx_int((( (Float)(section->__Field(HX_("lengthInSteps",3c,ed,41,db),::hx::paccDynamic)) ) / ( (Float)(4) )));
HXLINE(  38)					{
HXLINE(  38)						int _g1 = 0;
HXDLIN(  38)						::cpp::VirtualArray _g2 = ( (::cpp::VirtualArray)(section->__Field(HX_("sectionNotes",1c,c8,a7,fe),::hx::paccDynamic)) );
HXDLIN(  38)						while((_g1 < _g2->get_length())){
HXLINE(  38)							 ::Dynamic songNotes = _g2->__get(_g1);
HXDLIN(  38)							_g1 = (_g1 + 1);
HXLINE(  40)							Float songNotes1 = ( (Float)(songNotes->__GetItem(0)) );
HXDLIN(  40)							Float daStrumTime = (songNotes1 - ( (Float)(::Init_obj::trueSettings->get(HX_("Offset",b3,0b,d4,94))) ));
HXLINE(  41)							int daNoteData = ::Std_obj::_hx_int(::hx::Mod(songNotes->__GetItem(1),4));
HXLINE(  43)							Float daNoteAlt = ( (Float)(0) );
HXLINE(  46)							if (::hx::IsGreater( songNotes->__Field(HX_("length",e6,94,07,9f),::hx::paccDynamic),2 )) {
HXLINE(  47)								daNoteAlt = ( (Float)(songNotes->__GetItem(3)) );
            							}
HXLINE(  57)							bool gottaHitNote = ( (bool)(section->__Field(HX_("mustHitSection",3b,5f,87,62),::hx::paccDynamic)) );
HXLINE(  60)							if (::hx::IsGreater( songNotes->__GetItem(1),3 )) {
HXLINE(  61)								gottaHitNote = !(( (bool)(section->__Field(HX_("mustHitSection",3b,5f,87,62),::hx::paccDynamic)) ));
            							}
HXLINE(  64)							 ::gameObjects::userInterface::notes::Note oldNote;
HXLINE(  65)							if ((unspawnNotes->length > 0)) {
HXLINE(  66)								oldNote = unspawnNotes->__get(::Std_obj::_hx_int(( (Float)((unspawnNotes->length - 1)) ))).StaticCast<  ::gameObjects::userInterface::notes::Note >();
            							}
            							else {
HXLINE(  68)								oldNote = null();
            							}
HXLINE(  71)							 ::gameObjects::userInterface::notes::Note swagNote = ::ForeverAssets_obj::generateArrow(::meta::state::PlayState_obj::assetModifier,daStrumTime,daNoteData,0,daNoteAlt,null(),null());
HXLINE(  73)							swagNote->noteSpeed = ( (Float)(songData->__Field(HX_("speed",87,97,69,81),::hx::paccDynamic)) );
HXLINE(  76)							swagNote->sustainLength = ( (Float)(songNotes->__GetItem(2)) );
HXLINE(  77)							swagNote->scrollFactor->set(0,0);
HXLINE(  78)							Float susLength = swagNote->sustainLength;
HXLINE(  81)							susLength = (susLength / ::meta::data::Conductor_obj::stepCrochet);
HXLINE(  83)							unspawnNotes->push(swagNote);
HXLINE(  86)							{
HXLINE(  86)								int _g = 0;
HXDLIN(  86)								int _g3 = ::Math_obj::floor(susLength);
HXDLIN(  86)								while((_g < _g3)){
HXLINE(  86)									_g = (_g + 1);
HXDLIN(  86)									int susNote = (_g - 1);
HXLINE(  88)									oldNote = unspawnNotes->__get(::Std_obj::_hx_int(( (Float)((unspawnNotes->length - 1)) ))).StaticCast<  ::gameObjects::userInterface::notes::Note >();
HXLINE(  89)									 ::gameObjects::userInterface::notes::Note sustainNote = ::ForeverAssets_obj::generateArrow(::meta::state::PlayState_obj::assetModifier,((daStrumTime + (::meta::data::Conductor_obj::stepCrochet * ( (Float)(susNote) ))) + ::meta::data::Conductor_obj::stepCrochet),daNoteData,0,daNoteAlt,true,oldNote);
HXLINE(  93)									sustainNote->scrollFactor->set(null(),null());
HXLINE(  95)									unspawnNotes->push(sustainNote);
HXLINE(  96)									sustainNote->mustPress = gottaHitNote;
            								}
            							}
HXLINE( 104)							swagNote->mustPress = gottaHitNote;
            						}
            					}
HXLINE( 106)					daBeats = (daBeats + 1);
            				}
            			}
            		}
            		else {
HXLINE(  29)			if ((typeOfChart != HX_("forever",a7,ee,f4,d9))) {
HXLINE(  33)				int daBeats = 0;
HXLINE(  35)				{
HXLINE(  35)					int _g = 0;
HXDLIN(  35)					while((_g < noteData->length)){
HXLINE(  35)						 ::Dynamic section = noteData->__get(_g);
HXDLIN(  35)						_g = (_g + 1);
HXLINE(  36)						int coolSection = ::Std_obj::_hx_int((( (Float)(section->__Field(HX_("lengthInSteps",3c,ed,41,db),::hx::paccDynamic)) ) / ( (Float)(4) )));
HXLINE(  38)						{
HXLINE(  38)							int _g1 = 0;
HXDLIN(  38)							::cpp::VirtualArray _g2 = ( (::cpp::VirtualArray)(section->__Field(HX_("sectionNotes",1c,c8,a7,fe),::hx::paccDynamic)) );
HXDLIN(  38)							while((_g1 < _g2->get_length())){
HXLINE(  38)								 ::Dynamic songNotes = _g2->__get(_g1);
HXDLIN(  38)								_g1 = (_g1 + 1);
HXLINE(  40)								Float songNotes1 = ( (Float)(songNotes->__GetItem(0)) );
HXDLIN(  40)								Float daStrumTime = (songNotes1 - ( (Float)(::Init_obj::trueSettings->get(HX_("Offset",b3,0b,d4,94))) ));
HXLINE(  41)								int daNoteData = ::Std_obj::_hx_int(::hx::Mod(songNotes->__GetItem(1),4));
HXLINE(  43)								Float daNoteAlt = ( (Float)(0) );
HXLINE(  46)								if (::hx::IsGreater( songNotes->__Field(HX_("length",e6,94,07,9f),::hx::paccDynamic),2 )) {
HXLINE(  47)									daNoteAlt = ( (Float)(songNotes->__GetItem(3)) );
            								}
HXLINE(  57)								bool gottaHitNote = ( (bool)(section->__Field(HX_("mustHitSection",3b,5f,87,62),::hx::paccDynamic)) );
HXLINE(  60)								if (::hx::IsGreater( songNotes->__GetItem(1),3 )) {
HXLINE(  61)									gottaHitNote = !(( (bool)(section->__Field(HX_("mustHitSection",3b,5f,87,62),::hx::paccDynamic)) ));
            								}
HXLINE(  64)								 ::gameObjects::userInterface::notes::Note oldNote;
HXLINE(  65)								if ((unspawnNotes->length > 0)) {
HXLINE(  66)									oldNote = unspawnNotes->__get(::Std_obj::_hx_int(( (Float)((unspawnNotes->length - 1)) ))).StaticCast<  ::gameObjects::userInterface::notes::Note >();
            								}
            								else {
HXLINE(  68)									oldNote = null();
            								}
HXLINE(  71)								 ::gameObjects::userInterface::notes::Note swagNote = ::ForeverAssets_obj::generateArrow(::meta::state::PlayState_obj::assetModifier,daStrumTime,daNoteData,0,daNoteAlt,null(),null());
HXLINE(  73)								swagNote->noteSpeed = ( (Float)(songData->__Field(HX_("speed",87,97,69,81),::hx::paccDynamic)) );
HXLINE(  76)								swagNote->sustainLength = ( (Float)(songNotes->__GetItem(2)) );
HXLINE(  77)								swagNote->scrollFactor->set(0,0);
HXLINE(  78)								Float susLength = swagNote->sustainLength;
HXLINE(  81)								susLength = (susLength / ::meta::data::Conductor_obj::stepCrochet);
HXLINE(  83)								unspawnNotes->push(swagNote);
HXLINE(  86)								{
HXLINE(  86)									int _g = 0;
HXDLIN(  86)									int _g3 = ::Math_obj::floor(susLength);
HXDLIN(  86)									while((_g < _g3)){
HXLINE(  86)										_g = (_g + 1);
HXDLIN(  86)										int susNote = (_g - 1);
HXLINE(  88)										oldNote = unspawnNotes->__get(::Std_obj::_hx_int(( (Float)((unspawnNotes->length - 1)) ))).StaticCast<  ::gameObjects::userInterface::notes::Note >();
HXLINE(  89)										 ::gameObjects::userInterface::notes::Note sustainNote = ::ForeverAssets_obj::generateArrow(::meta::state::PlayState_obj::assetModifier,((daStrumTime + (::meta::data::Conductor_obj::stepCrochet * ( (Float)(susNote) ))) + ::meta::data::Conductor_obj::stepCrochet),daNoteData,0,daNoteAlt,true,oldNote);
HXLINE(  93)										sustainNote->scrollFactor->set(null(),null());
HXLINE(  95)										unspawnNotes->push(sustainNote);
HXLINE(  96)										sustainNote->mustPress = gottaHitNote;
            									}
            								}
HXLINE( 104)								swagNote->mustPress = gottaHitNote;
            							}
            						}
HXLINE( 106)						daBeats = (daBeats + 1);
            					}
            				}
            			}
            		}
HXLINE( 124)		return unspawnNotes;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(ChartLoader_obj,generateChartType,return )


ChartLoader_obj::ChartLoader_obj()
{
}

bool ChartLoader_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 17:
		if (HX_FIELD_EQ(inName,"generateChartType") ) { outValue = generateChartType_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ChartLoader_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *ChartLoader_obj_sStaticStorageInfo = 0;
#endif

::hx::Class ChartLoader_obj::__mClass;

static ::String ChartLoader_obj_sStaticFields[] = {
	HX_("generateChartType",c3,f4,5f,1e),
	::String(null())
};

void ChartLoader_obj::__register()
{
	ChartLoader_obj _hx_dummy;
	ChartLoader_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("meta.data.ChartLoader",f6,8e,74,af);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ChartLoader_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ChartLoader_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< ChartLoader_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ChartLoader_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ChartLoader_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace meta
} // end namespace data
