// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_Init
#include <Init.h>
#endif
#ifndef INCLUDED_Lambda
#include <Lambda.h>
#endif
#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_SettingTypes
#include <SettingTypes.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_TransitionData
#include <flixel/addons/transition/TransitionData.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSave
#include <flixel/util/FlxSave.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_meta_CoolUtil
#include <meta/CoolUtil.h>
#endif
#ifndef INCLUDED_meta_InfoHud
#include <meta/InfoHud.h>
#endif
#ifndef INCLUDED_meta_MusicBeatState
#include <meta/MusicBeatState.h>
#endif
#ifndef INCLUDED_meta_data_Highscore
#include <meta/data/Highscore.h>
#endif
#ifndef INCLUDED_meta_data_dependency_FNFUIState
#include <meta/data/dependency/FNFUIState.h>
#endif
#ifndef INCLUDED_meta_state_CustomTitlescreen
#include <meta/state/CustomTitlescreen.h>
#endif
#ifndef INCLUDED_meta_state_TitleState
#include <meta/state/TitleState.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_filters_BitmapFilter
#include <openfl/filters/BitmapFilter.h>
#endif
#ifndef INCLUDED_openfl_filters_ColorMatrixFilter
#include <openfl/filters/ColorMatrixFilter.h>
#endif
#ifndef INCLUDED_openfl_text_TextField
#include <openfl/text/TextField.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_30_new,"Init","new",0x124b6022,"Init.new","Init.hx",30,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_195_create,"Init","create",0xc4369c7a,"Init.create","Init.hx",195,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_220_gotoTitleScreen,"Init","gotoTitleScreen",0x442a9d03,"Init.gotoTitleScreen","Init.hx",220,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_227_loadSettings,"Init","loadSettings",0x0d33d127,"Init.loadSettings","Init.hx",227,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_270_loadControls,"Init","loadControls",0xb9b2daba,"Init.loadControls","Init.hx",270,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_278_saveSettings,"Init","saveSettings",0x6653313e,"Init.saveSettings","Init.hx",278,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_287_saveControls,"Init","saveControls",0x12d23ad1,"Init.saveControls","Init.hx",287,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_293_updateAll,"Init","updateAll",0xe8a7a3da,"Init.updateAll","Init.hx",293,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_42_boot,"Init","boot",0xe7c1be30,"Init.boot","Init.hx",42,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_43_boot,"Init","boot",0xe7c1be30,"Init.boot","Init.hx",43,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_45_boot,"Init","boot",0xe7c1be30,"Init.boot","Init.hx",45,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_148_boot,"Init","boot",0xe7c1be30,"Init.boot","Init.hx",148,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_149_boot,"Init","boot",0xe7c1be30,"Init.boot","Init.hx",149,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_151_boot,"Init","boot",0xe7c1be30,"Init.boot","Init.hx",151,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_162_boot,"Init","boot",0xe7c1be30,"Init.boot","Init.hx",162,0x98c3798e)
HX_LOCAL_STACK_FRAME(_hx_pos_b87dd22ec8b85d73_164_boot,"Init","boot",0xe7c1be30,"Init.boot","Init.hx",164,0x98c3798e)
static const Float _hx_array_data_30946730_20[] = {
	0.43,0.72,-.15,(Float)0,(Float)0,0.34,0.57,0.09,(Float)0,(Float)0,-.02,0.03,(Float)1,(Float)0,(Float)0,(Float)0,(Float)0,(Float)0,(Float)1,(Float)0,
};
static const Float _hx_array_data_30946730_21[] = {
	0.20,0.99,-.19,(Float)0,(Float)0,0.16,0.79,0.04,(Float)0,(Float)0,0.01,-.01,(Float)1,(Float)0,(Float)0,(Float)0,(Float)0,(Float)0,(Float)1,(Float)0,
};
static const Float _hx_array_data_30946730_22[] = {
	0.97,0.11,-.08,(Float)0,(Float)0,0.02,0.82,0.16,(Float)0,(Float)0,0.06,0.88,0.18,(Float)0,(Float)0,(Float)0,(Float)0,(Float)0,(Float)1,(Float)0,
};

void Init_obj::__construct( ::Dynamic MaxSize){
            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_30_new)
HXDLIN(  30)		super::__construct(MaxSize);
            	}

Dynamic Init_obj::__CreateEmpty() { return new Init_obj; }

void *Init_obj::_hx_vtable = 0;

Dynamic Init_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Init_obj > _hx_result = new Init_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Init_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x62817b24) {
		if (inClassId<=(int)0x04e75d54) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x04e75d54;
		} else {
			return inClassId==(int)0x62817b24;
		}
	} else {
		return inClassId==(int)0x7c795c9f || inClassId==(int)0x7ccf8994;
	}
}

void Init_obj::create(){
            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_195_create)
HXLINE( 196)		::flixel::FlxG_obj::save->bind(HX_("foreverengine-options",7a,c1,0f,d9),null());
HXLINE( 197)		::meta::data::Highscore_obj::load();
HXLINE( 199)		::Init_obj::loadSettings();
HXLINE( 200)		::Init_obj::loadControls();
HXLINE( 203)		::Main_obj::updateFramerate(( (int)(::Init_obj::trueSettings->get(HX_("Framerate Cap",bf,7f,6c,1f))) ));
HXLINE( 207)		::flixel::FlxG_obj::game->setFilters(::Init_obj::filters);
HXLINE( 210)		::flixel::FlxG_obj::fixedTimestep = false;
HXLINE( 211)		::flixel::FlxG_obj::mouse->set_useSystemCursor(true);
HXLINE( 212)		::flixel::FlxG_obj::mouse->set_visible(false);
HXLINE( 215)		this->gotoTitleScreen();
            	}


void Init_obj::gotoTitleScreen(){
            	HX_GC_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_220_gotoTitleScreen)
HXDLIN( 220)		if (( (bool)(::Init_obj::trueSettings->get(HX_("Custom Titlescreen",15,d0,ce,87))) )) {
HXLINE( 221)			::Main_obj::switchState(::hx::ObjectPtr<OBJ_>(this), ::meta::state::CustomTitlescreen_obj::__alloc( HX_CTX ,null(),null()));
            		}
            		else {
HXLINE( 223)			::Main_obj::switchState(::hx::ObjectPtr<OBJ_>(this), ::meta::state::TitleState_obj::__alloc( HX_CTX ,null(),null()));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Init_obj,gotoTitleScreen,(void))

::String Init_obj::FORCED;

::String Init_obj::NOT_FORCED;

 ::haxe::ds::StringMap Init_obj::gameSettings;

 ::haxe::ds::StringMap Init_obj::trueSettings;

 ::haxe::ds::StringMap Init_obj::settingsDescriptions;

 ::haxe::ds::StringMap Init_obj::gameControls;

::Array< ::Dynamic> Init_obj::filters;

 ::haxe::ds::StringMap Init_obj::gameFilters;

void Init_obj::loadSettings(){
            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_227_loadSettings)
HXLINE( 232)		{
HXLINE( 232)			 ::Dynamic setting = ::Init_obj::gameSettings->keys();
HXDLIN( 232)			while(( (bool)(setting->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 232)				::String setting1 = ( (::String)(setting->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 233)				::Dynamic this1 = ::Init_obj::trueSettings;
HXDLIN( 233)				( ( ::haxe::ds::StringMap)(this1) )->set(setting1,::Init_obj::gameSettings->get(setting1)->__GetItem(0));
            			}
            		}
HXLINE( 237)		if (::hx::IsNotNull( ::flixel::FlxG_obj::save->data->__Field(HX_("settings",e3,7c,3d,8b),::hx::paccDynamic) )) {
HXLINE( 239)			 ::haxe::ds::StringMap settingsMap = ( ( ::haxe::ds::StringMap)(::flixel::FlxG_obj::save->data->__Field(HX_("settings",e3,7c,3d,8b),::hx::paccDynamic)) );
HXLINE( 240)			{
HXLINE( 240)				 ::Dynamic singularSetting = settingsMap->keys();
HXDLIN( 240)				while(( (bool)(singularSetting->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 240)					::String singularSetting1 = ( (::String)(singularSetting->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 241)					bool _hx_tmp;
HXDLIN( 241)					if (::hx::IsNotNull( ::Init_obj::gameSettings->get(singularSetting1) )) {
HXLINE( 241)						::String _hx_tmp1 = ( (::String)(::Init_obj::gameSettings->get(singularSetting1)->__GetItem(3)) );
HXDLIN( 241)						_hx_tmp = (_hx_tmp1 != ::Init_obj::FORCED);
            					}
            					else {
HXLINE( 241)						_hx_tmp = false;
            					}
HXDLIN( 241)					if (_hx_tmp) {
HXLINE( 242)						::Dynamic this1 = ::Init_obj::trueSettings;
HXDLIN( 242)						( ( ::haxe::ds::StringMap)(this1) )->set(singularSetting1, ::Dynamic(::flixel::FlxG_obj::save->data->__Field(HX_("settings",e3,7c,3d,8b),::hx::paccDynamic))->__Field(HX_("get",96,80,4e,00),::hx::paccDynamic)(singularSetting1));
            					}
            				}
            			}
            		}
HXLINE( 246)		bool _hx_tmp;
HXDLIN( 246)		bool _hx_tmp1;
HXDLIN( 246)		if (::Std_obj::isOfType(::Init_obj::trueSettings->get(HX_("Framerate Cap",bf,7f,6c,1f)),::hx::ClassOf< int >())) {
HXLINE( 246)			_hx_tmp1 = ::hx::IsLess( ::Init_obj::trueSettings->get(HX_("Framerate Cap",bf,7f,6c,1f)),30 );
            		}
            		else {
HXLINE( 246)			_hx_tmp1 = true;
            		}
HXDLIN( 246)		if (!(_hx_tmp1)) {
HXLINE( 246)			_hx_tmp = ::hx::IsGreater( ::Init_obj::trueSettings->get(HX_("Framerate Cap",bf,7f,6c,1f)),360 );
            		}
            		else {
HXLINE( 246)			_hx_tmp = true;
            		}
HXDLIN( 246)		if (_hx_tmp) {
HXLINE( 249)			::Init_obj::trueSettings->set(HX_("Framerate Cap",bf,7f,6c,1f),30);
            		}
HXLINE( 251)		bool _hx_tmp2;
HXDLIN( 251)		bool _hx_tmp3;
HXDLIN( 251)		if (::Std_obj::isOfType(::Init_obj::trueSettings->get(HX_("Stage Darkness",ef,05,99,24)),::hx::ClassOf< int >())) {
HXLINE( 251)			_hx_tmp3 = ::hx::IsLess( ::Init_obj::trueSettings->get(HX_("Stage Darkness",ef,05,99,24)),0 );
            		}
            		else {
HXLINE( 251)			_hx_tmp3 = true;
            		}
HXDLIN( 251)		if (!(_hx_tmp3)) {
HXLINE( 251)			_hx_tmp2 = ::hx::IsGreater( ::Init_obj::trueSettings->get(HX_("Stage Darkness",ef,05,99,24)),100 );
            		}
            		else {
HXLINE( 251)			_hx_tmp2 = true;
            		}
HXDLIN( 251)		if (_hx_tmp2) {
HXLINE( 254)			::Init_obj::trueSettings->set(HX_("Stage Darkness",ef,05,99,24),0);
            		}
HXLINE( 257)		::Init_obj::gameSettings->get(HX_("UI Skin",e9,97,ae,a2))->__SetItem(4,::meta::CoolUtil_obj::returnAssetsLibrary(HX_("UI",54,4a,00,00),null()));
HXLINE( 258)		 ::Dynamic _hx_tmp4 = ::Init_obj::gameSettings->get(HX_("UI Skin",e9,97,ae,a2))->__GetItem(4);
HXDLIN( 258)		 ::Dynamic _hx_tmp5 = ::Init_obj::trueSettings->get(HX_("UI Skin",e9,97,ae,a2));
HXDLIN( 258)		if (!(( (bool)(_hx_tmp4->__Field(HX_("contains",1f,5a,7b,2c),::hx::paccDynamic)(_hx_tmp5)) ))) {
HXLINE( 259)			::Init_obj::trueSettings->set(HX_("UI Skin",e9,97,ae,a2),HX_("default",c1,d8,c3,9b));
            		}
HXLINE( 260)		::Init_obj::gameSettings->get(HX_("Note Skin",6b,8d,33,f0))->__SetItem(4,::meta::CoolUtil_obj::returnAssetsLibrary(HX_("noteskins/notes",d6,76,75,6d),null()));
HXLINE( 261)		 ::Dynamic _hx_tmp6 = ::Init_obj::gameSettings->get(HX_("Note Skin",6b,8d,33,f0))->__GetItem(4);
HXDLIN( 261)		 ::Dynamic _hx_tmp7 = ::Init_obj::trueSettings->get(HX_("Note Skin",6b,8d,33,f0));
HXDLIN( 261)		if (!(( (bool)(_hx_tmp6->__Field(HX_("contains",1f,5a,7b,2c),::hx::paccDynamic)(_hx_tmp7)) ))) {
HXLINE( 262)			::Init_obj::trueSettings->set(HX_("Note Skin",6b,8d,33,f0),HX_("default",c1,d8,c3,9b));
            		}
HXLINE( 264)		::Init_obj::saveSettings();
HXLINE( 266)		::Init_obj::updateAll();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Init_obj,loadSettings,(void))

void Init_obj::loadControls(){
            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_270_loadControls)
HXLINE( 271)		bool _hx_tmp;
HXDLIN( 271)		if (::hx::IsNotNull( ::flixel::FlxG_obj::save->data->__Field(HX_("gameControls",88,78,ad,72),::hx::paccDynamic) )) {
HXLINE( 271)			int _hx_tmp1 = ::Lambda_obj::count(::flixel::FlxG_obj::save->data->__Field(HX_("gameControls",88,78,ad,72),::hx::paccDynamic),null());
HXDLIN( 271)			_hx_tmp = (_hx_tmp1 == ::Lambda_obj::count(::Init_obj::gameControls,null()));
            		}
            		else {
HXLINE( 271)			_hx_tmp = false;
            		}
HXDLIN( 271)		if (_hx_tmp) {
HXLINE( 272)			::Init_obj::gameControls = ( ( ::haxe::ds::StringMap)(::flixel::FlxG_obj::save->data->__Field(HX_("gameControls",88,78,ad,72),::hx::paccDynamic)) );
            		}
HXLINE( 274)		::Init_obj::saveControls();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Init_obj,loadControls,(void))

void Init_obj::saveSettings(){
            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_278_saveSettings)
HXLINE( 280)		::flixel::FlxG_obj::save->data->__SetField(HX_("settings",e3,7c,3d,8b),::Init_obj::trueSettings,::hx::paccDynamic);
HXLINE( 281)		::flixel::FlxG_obj::save->flush(null(),null());
HXLINE( 283)		::Init_obj::updateAll();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Init_obj,saveSettings,(void))

void Init_obj::saveControls(){
            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_287_saveControls)
HXLINE( 288)		::flixel::FlxG_obj::save->data->__SetField(HX_("gameControls",88,78,ad,72),::Init_obj::gameControls,::hx::paccDynamic);
HXLINE( 289)		::flixel::FlxG_obj::save->flush(null(),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Init_obj,saveControls,(void))

void Init_obj::updateAll(){
            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_293_updateAll)
HXLINE( 294)		 ::Dynamic _hx_tmp = ::Init_obj::trueSettings->get(HX_("FPS Counter",85,ef,54,c9));
HXDLIN( 294)		 ::Dynamic _hx_tmp1 = ::Init_obj::trueSettings->get(HX_("Debug Info",9b,59,ce,ff));
HXDLIN( 294)		::meta::InfoHud_obj::updateDisplayInfo(( (bool)(_hx_tmp) ),( (bool)(_hx_tmp1) ),( (bool)(::Init_obj::trueSettings->get(HX_("Memory Counter",dd,e2,42,58))) ));
HXLINE( 297)		::Main_obj::updateFramerate(( (int)(::Init_obj::trueSettings->get(HX_("Framerate Cap",bf,7f,6c,1f))) ));
HXLINE( 301)		::Init_obj::filters = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 302)		::flixel::FlxG_obj::game->setFilters(::Init_obj::filters);
HXLINE( 304)		::String theFilter = ::Init_obj::trueSettings->get_string(HX_("Filter",d8,93,c9,b9));
HXLINE( 305)		if (::hx::IsNotNull( ::Init_obj::gameFilters->get(theFilter) )) {
HXLINE( 307)			 ::openfl::filters::BitmapFilter realFilter = ( ( ::openfl::filters::BitmapFilter)(::Init_obj::gameFilters->get(theFilter)->__Field(HX_("filter",b8,1f,35,85),::hx::paccDynamic)) );
HXLINE( 309)			if (::hx::IsNotNull( realFilter )) {
HXLINE( 310)				::Init_obj::filters->push(realFilter);
            			}
            		}
HXLINE( 313)		::flixel::FlxG_obj::game->setFilters(::Init_obj::filters);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Init_obj,updateAll,(void))


::hx::ObjectPtr< Init_obj > Init_obj::__new( ::Dynamic MaxSize) {
	::hx::ObjectPtr< Init_obj > __this = new Init_obj();
	__this->__construct(MaxSize);
	return __this;
}

::hx::ObjectPtr< Init_obj > Init_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic MaxSize) {
	Init_obj *__this = (Init_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Init_obj), true, "Init"));
	*(void **)__this = Init_obj::_hx_vtable;
	__this->__construct(MaxSize);
	return __this;
}

Init_obj::Init_obj()
{
}

::hx::Val Init_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"gotoTitleScreen") ) { return ::hx::Val( gotoTitleScreen_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Init_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"FORCED") ) { outValue = ( FORCED ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"filters") ) { outValue = ( filters ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"updateAll") ) { outValue = updateAll_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"NOT_FORCED") ) { outValue = ( NOT_FORCED ); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"gameFilters") ) { outValue = ( gameFilters ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"gameSettings") ) { outValue = ( gameSettings ); return true; }
		if (HX_FIELD_EQ(inName,"trueSettings") ) { outValue = ( trueSettings ); return true; }
		if (HX_FIELD_EQ(inName,"gameControls") ) { outValue = ( gameControls ); return true; }
		if (HX_FIELD_EQ(inName,"loadSettings") ) { outValue = loadSettings_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"loadControls") ) { outValue = loadControls_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"saveSettings") ) { outValue = saveSettings_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"saveControls") ) { outValue = saveControls_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"settingsDescriptions") ) { outValue = ( settingsDescriptions ); return true; }
	}
	return false;
}

bool Init_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"FORCED") ) { FORCED=ioValue.Cast< ::String >(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"filters") ) { filters=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"NOT_FORCED") ) { NOT_FORCED=ioValue.Cast< ::String >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"gameFilters") ) { gameFilters=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"gameSettings") ) { gameSettings=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		if (HX_FIELD_EQ(inName,"trueSettings") ) { trueSettings=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		if (HX_FIELD_EQ(inName,"gameControls") ) { gameControls=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"settingsDescriptions") ) { settingsDescriptions=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Init_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo Init_obj_sStaticStorageInfo[] = {
	{::hx::fsString,(void *) &Init_obj::FORCED,HX_("FORCED",19,a8,09,b0)},
	{::hx::fsString,(void *) &Init_obj::NOT_FORCED,HX_("NOT_FORCED",25,19,3e,92)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &Init_obj::gameSettings,HX_("gameSettings",f5,6e,2e,c6)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &Init_obj::trueSettings,HX_("trueSettings",51,de,ff,ad)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &Init_obj::settingsDescriptions,HX_("settingsDescriptions",7a,e5,93,ab)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &Init_obj::gameControls,HX_("gameControls",88,78,ad,72)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(void *) &Init_obj::filters,HX_("filters",bb,a1,46,09)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &Init_obj::gameFilters,HX_("gameFilters",e9,17,fd,ed)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String Init_obj_sMemberFields[] = {
	HX_("create",fc,66,0f,7c),
	HX_("gotoTitleScreen",41,72,b9,39),
	::String(null()) };

static void Init_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Init_obj::FORCED,"FORCED");
	HX_MARK_MEMBER_NAME(Init_obj::NOT_FORCED,"NOT_FORCED");
	HX_MARK_MEMBER_NAME(Init_obj::gameSettings,"gameSettings");
	HX_MARK_MEMBER_NAME(Init_obj::trueSettings,"trueSettings");
	HX_MARK_MEMBER_NAME(Init_obj::settingsDescriptions,"settingsDescriptions");
	HX_MARK_MEMBER_NAME(Init_obj::gameControls,"gameControls");
	HX_MARK_MEMBER_NAME(Init_obj::filters,"filters");
	HX_MARK_MEMBER_NAME(Init_obj::gameFilters,"gameFilters");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Init_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Init_obj::FORCED,"FORCED");
	HX_VISIT_MEMBER_NAME(Init_obj::NOT_FORCED,"NOT_FORCED");
	HX_VISIT_MEMBER_NAME(Init_obj::gameSettings,"gameSettings");
	HX_VISIT_MEMBER_NAME(Init_obj::trueSettings,"trueSettings");
	HX_VISIT_MEMBER_NAME(Init_obj::settingsDescriptions,"settingsDescriptions");
	HX_VISIT_MEMBER_NAME(Init_obj::gameControls,"gameControls");
	HX_VISIT_MEMBER_NAME(Init_obj::filters,"filters");
	HX_VISIT_MEMBER_NAME(Init_obj::gameFilters,"gameFilters");
};

#endif

::hx::Class Init_obj::__mClass;

static ::String Init_obj_sStaticFields[] = {
	HX_("FORCED",19,a8,09,b0),
	HX_("NOT_FORCED",25,19,3e,92),
	HX_("gameSettings",f5,6e,2e,c6),
	HX_("trueSettings",51,de,ff,ad),
	HX_("settingsDescriptions",7a,e5,93,ab),
	HX_("gameControls",88,78,ad,72),
	HX_("filters",bb,a1,46,09),
	HX_("gameFilters",e9,17,fd,ed),
	HX_("loadSettings",29,69,a6,44),
	HX_("loadControls",bc,72,25,f1),
	HX_("saveSettings",40,c9,c5,9d),
	HX_("saveControls",d3,d2,44,4a),
	HX_("updateAll",98,d6,d6,82),
	::String(null())
};

void Init_obj::__register()
{
	Init_obj _hx_dummy;
	Init_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Init",30,67,94,30);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Init_obj::__GetStatic;
	__mClass->mSetStaticField = &Init_obj::__SetStatic;
	__mClass->mMarkFunc = Init_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Init_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Init_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Init_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Init_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Init_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Init_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Init_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_42_boot)
HXDLIN(  42)		FORCED = HX_("forced",19,fc,86,fd);
            	}
{
            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_43_boot)
HXDLIN(  43)		NOT_FORCED = HX_("not forced",86,93,bd,31);
            	}
{
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::haxe::ds::StringMap _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_45_boot)
HXDLIN(  45)			 ::haxe::ds::StringMap _g =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN(  45)			_g->set(HX_("Downscroll",0f,4a,85,46),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Whether to have the strumline vertically flipped in gameplay.",78,b8,92,50))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Auto Pause",85,73,d8,49),::cpp::VirtualArray_obj::__new(4)->init(0,true)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("",00,00,00,00))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("FPS Counter",85,ef,54,c9),::cpp::VirtualArray_obj::__new(4)->init(0,true)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Whether to display the FPS counter.",30,44,44,3a))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Memory Counter",dd,e2,42,58),::cpp::VirtualArray_obj::__new(4)->init(0,true)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Whether to display approximately how much memory is being used.",4d,72,a6,45))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Debug Info",9b,59,ce,ff),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Whether to display information like your game state.",7b,f8,6c,60))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Reduced Movements",82,8d,f2,cf),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Whether to reduce movements, like icons bouncing or beat zooms in gameplay.",be,3f,81,e2))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Stage Darkness",ef,05,99,24),::cpp::VirtualArray_obj::__new(4)->init(0,::SettingTypes_obj::Checkmark_dyn())->init(1,::SettingTypes_obj::Selector_dyn())->init(2,HX_("Darkens non-ui elements, useful if you find the characters and backgrounds distracting.",7b,75,b5,b0))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Display Accuracy",17,3c,f2,a7),::cpp::VirtualArray_obj::__new(4)->init(0,true)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Whether to display your accuracy on screen.",13,11,18,4b))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Disable Antialiasing",6c,04,2e,d8),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Whether to disable Anti-aliasing. Helps improve performance in FPS.",9d,f4,41,08))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("No Camera Note Movement",a1,da,3d,d1),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("When enabled, left and right notes no longer move the camera.",39,c2,45,0a))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Use Forever Chart Editor",c1,46,1b,e4),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("When enabled, uses the custom Forever Engine chart editor!",c8,0f,c6,9b))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Disable Note Splashes",2b,53,9d,28),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Whether to disable note splashes in gameplay. Useful if you find them distracting.",0d,e8,73,5f))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Offset",b3,0b,d4,94),::cpp::VirtualArray_obj::__new(2)->init(0,::SettingTypes_obj::Checkmark_dyn())->init(1,3));
HXDLIN(  45)			_g->set(HX_("Filter",d8,93,c9,b9),::cpp::VirtualArray_obj::__new(5)->init(0,HX_("none",b8,12,0a,49))->init(1,::SettingTypes_obj::Selector_dyn())->init(2,HX_("Choose a filter for colorblindness.",0e,ca,b1,33))->init(3,::Init_obj::NOT_FORCED)->init(4,::cpp::VirtualArray_obj::__new(4)->init(0,HX_("none",b8,12,0a,49))->init(1,HX_("Deuteranopia",13,8b,e1,43))->init(2,HX_("Protanopia",ad,59,c5,13))->init(3,HX_("Tritanopia",6f,8c,c0,bd))));
HXDLIN(  45)			_g->set(HX_("UI Skin",e9,97,ae,a2),::cpp::VirtualArray_obj::__new(5)->init(0,HX_("default",c1,d8,c3,9b))->init(1,::SettingTypes_obj::Selector_dyn())->init(2,HX_("Choose a UI Skin for judgements, combo, etc.",14,15,3b,35))->init(3,::Init_obj::NOT_FORCED)->init(4,HX_("",00,00,00,00)));
HXDLIN(  45)			_g->set(HX_("Note Skin",6b,8d,33,f0),::cpp::VirtualArray_obj::__new(5)->init(0,HX_("default",c1,d8,c3,9b))->init(1,::SettingTypes_obj::Selector_dyn())->init(2,HX_("Choose a note skin.",8b,40,79,1c))->init(3,::Init_obj::NOT_FORCED)->init(4,HX_("",00,00,00,00)));
HXDLIN(  45)			_g->set(HX_("Framerate Cap",bf,7f,6c,1f),::cpp::VirtualArray_obj::__new(5)->init(0,120)->init(1,::SettingTypes_obj::Selector_dyn())->init(2,HX_("Define your maximum FPS.",0d,2a,b1,fe))->init(3,::Init_obj::NOT_FORCED)->init(4,::cpp::VirtualArray_obj::__new(1)->init(0,HX_("",00,00,00,00))));
HXDLIN(  45)			_g->set(HX_("Opaque Arrows",e9,a3,c6,17),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Makes the arrows at the top of the screen opaque again.",f6,c7,6e,58))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Opaque Holds",d5,d1,24,ba),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Huh, why isnt the trail cut off?",e0,bc,7d,eb))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Ghost Tapping",44,6c,9f,40),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Enables Ghost Tapping, allowing you to press inputs without missing.",95,52,28,84))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Centered Notefield",dc,a5,a6,0e),::cpp::VirtualArray_obj::__new(3)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Center the notes, disables the enemy's notes.",42,03,c6,7a)));
HXDLIN(  45)			_g->set(HX_("Custom Titlescreen",15,d0,ce,87),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Enables the custom Forever Engine titlescreen! (only effective with a restart)",a0,57,8f,09))->init(3,::Init_obj::FORCED));
HXDLIN(  45)			_g->set(HX_("Skip Text",ee,65,46,c7),::cpp::VirtualArray_obj::__new(5)->init(0,HX_("freeplay only",ec,40,4e,0b))->init(1,::SettingTypes_obj::Selector_dyn())->init(2,HX_("Decides whether to skip cutscenes and dialogue in gameplay. May be always, only in freeplay, or never.",66,6e,09,cd))->init(3,::Init_obj::NOT_FORCED)->init(4,::cpp::VirtualArray_obj::__new(3)->init(0,HX_("never",8c,3e,30,99))->init(1,HX_("freeplay only",ec,40,4e,0b))->init(2,HX_("always",cf,0e,d7,46))));
HXDLIN(  45)			_g->set(HX_("Fixed Judgements",8a,ad,a6,9b),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Fixes the judgements to the camera instead of to the world itself, making them easier to read.",46,1a,74,a5))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			_g->set(HX_("Simply Judgements",b8,b3,c4,d7),::cpp::VirtualArray_obj::__new(4)->init(0,false)->init(1,::SettingTypes_obj::Checkmark_dyn())->init(2,HX_("Simplifies the judgement animations, displaying only one judgement / rating sprite at a time.",4d,9f,74,79))->init(3,::Init_obj::NOT_FORCED));
HXDLIN(  45)			return _g;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_45_boot)
HXDLIN(  45)		gameSettings = ( ( ::haxe::ds::StringMap)( ::Dynamic(new _hx_Closure_0())()) );
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_148_boot)
HXDLIN( 148)		trueSettings =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_149_boot)
HXDLIN( 149)		settingsDescriptions =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
{
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::haxe::ds::StringMap _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_151_boot)
HXDLIN( 151)			 ::haxe::ds::StringMap _g =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN( 151)			_g->set(HX_("UP",5b,4a,00,00),::cpp::VirtualArray_obj::__new(2)->init(0,::cpp::VirtualArray_obj::__new(2)->init(0,38)->init(1,87))->init(1,2));
HXDLIN( 151)			_g->set(HX_("DOWN",62,c0,2e,2d),::cpp::VirtualArray_obj::__new(2)->init(0,::cpp::VirtualArray_obj::__new(2)->init(0,40)->init(1,83))->init(1,1));
HXDLIN( 151)			_g->set(HX_("LEFT",07,d0,70,32),::cpp::VirtualArray_obj::__new(2)->init(0,::cpp::VirtualArray_obj::__new(2)->init(0,37)->init(1,65))->init(1,0));
HXDLIN( 151)			_g->set(HX_("RIGHT",bc,43,52,67),::cpp::VirtualArray_obj::__new(2)->init(0,::cpp::VirtualArray_obj::__new(2)->init(0,39)->init(1,68))->init(1,3));
HXDLIN( 151)			_g->set(HX_("ACCEPT",08,3f,89,bd),::cpp::VirtualArray_obj::__new(2)->init(0,::cpp::VirtualArray_obj::__new(3)->init(0,32)->init(1,90)->init(2,13))->init(1,4));
HXDLIN( 151)			_g->set(HX_("BACK",27,a2,d1,2b),::cpp::VirtualArray_obj::__new(2)->init(0,::cpp::VirtualArray_obj::__new(3)->init(0,8)->init(1,88)->init(2,27))->init(1,5));
HXDLIN( 151)			_g->set(HX_("PAUSE",d6,0e,46,3b),::cpp::VirtualArray_obj::__new(2)->init(0,::cpp::VirtualArray_obj::__new(2)->init(0,13)->init(1,80))->init(1,6));
HXDLIN( 151)			_g->set(HX_("RESET",af,81,b6,64),::cpp::VirtualArray_obj::__new(2)->init(0,::cpp::VirtualArray_obj::__new(2)->init(0,82)->init(1,null()))->init(1,7));
HXDLIN( 151)			return _g;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_151_boot)
HXDLIN( 151)		gameControls = ( ( ::haxe::ds::StringMap)( ::Dynamic(new _hx_Closure_0())()) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_162_boot)
HXDLIN( 162)		filters = ::Array_obj< ::Dynamic>::__new(0);
            	}
{
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::haxe::ds::StringMap _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_164_boot)
HXDLIN( 164)			 ::haxe::ds::StringMap _g =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN( 164)			{
HXLINE( 166)				::Array< Float > matrix = ::Array_obj< Float >::fromData( _hx_array_data_30946730_20,20);
HXLINE( 164)				_g->set(HX_("Deuteranopia",13,8b,e1,43), ::Dynamic(::hx::Anon_obj::Create(1)
            					->setFixed(0,HX_("filter",b8,1f,35,85),( ( ::openfl::filters::BitmapFilter)( ::openfl::filters::ColorMatrixFilter_obj::__alloc( HX_CTX ,matrix)) ))));
            			}
HXDLIN( 164)			{
HXLINE( 175)				::Array< Float > matrix1 = ::Array_obj< Float >::fromData( _hx_array_data_30946730_21,20);
HXLINE( 164)				_g->set(HX_("Protanopia",ad,59,c5,13), ::Dynamic(::hx::Anon_obj::Create(1)
            					->setFixed(0,HX_("filter",b8,1f,35,85),( ( ::openfl::filters::BitmapFilter)( ::openfl::filters::ColorMatrixFilter_obj::__alloc( HX_CTX ,matrix1)) ))));
            			}
HXDLIN( 164)			{
HXLINE( 184)				::Array< Float > matrix2 = ::Array_obj< Float >::fromData( _hx_array_data_30946730_22,20);
HXLINE( 164)				_g->set(HX_("Tritanopia",6f,8c,c0,bd), ::Dynamic(::hx::Anon_obj::Create(1)
            					->setFixed(0,HX_("filter",b8,1f,35,85),( ( ::openfl::filters::BitmapFilter)( ::openfl::filters::ColorMatrixFilter_obj::__alloc( HX_CTX ,matrix2)) ))));
            			}
HXDLIN( 164)			return _g;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_b87dd22ec8b85d73_164_boot)
HXDLIN( 164)		gameFilters = ( ( ::haxe::ds::StringMap)( ::Dynamic(new _hx_Closure_0())()) );
            	}
}

