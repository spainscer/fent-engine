// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_ForeverAssets
#include <ForeverAssets.h>
#endif
#ifndef INCLUDED_Init
#include <Init.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRandom
#include <flixel/math/FlxRandom.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxEase
#include <flixel/tweens/FlxEase.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_VarTween
#include <flixel/tweens/misc/VarTween.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSort
#include <flixel/util/FlxSort.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_gameObjects_Character
#include <gameObjects/Character.h>
#endif
#ifndef INCLUDED_gameObjects_userInterface_notes_Note
#include <gameObjects/userInterface/notes/Note.h>
#endif
#ifndef INCLUDED_gameObjects_userInterface_notes_NoteSplash
#include <gameObjects/userInterface/notes/NoteSplash.h>
#endif
#ifndef INCLUDED_gameObjects_userInterface_notes_Strumline
#include <gameObjects/userInterface/notes/Strumline.h>
#endif
#ifndef INCLUDED_gameObjects_userInterface_notes_UIStaticArrow
#include <gameObjects/userInterface/notes/UIStaticArrow.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_meta_MusicBeatState
#include <meta/MusicBeatState.h>
#endif
#ifndef INCLUDED_meta_data_dependency_FNFSprite
#include <meta/data/dependency/FNFSprite.h>
#endif
#ifndef INCLUDED_meta_data_dependency_FNFUIState
#include <meta/data/dependency/FNFUIState.h>
#endif
#ifndef INCLUDED_meta_state_PlayState
#include <meta/state/PlayState.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_629eb1fb3c846ad3_124_new,"gameObjects.userInterface.notes.Strumline","new",0x43aaa136,"gameObjects.userInterface.notes.Strumline.new","gameObjects/userInterface/notes/Strumline.hx",124,0xf50b2cbd)
HX_LOCAL_STACK_FRAME(_hx_pos_629eb1fb3c846ad3_181_createSplash,"gameObjects.userInterface.notes.Strumline","createSplash",0xc37d25ed,"gameObjects.userInterface.notes.Strumline.createSplash","gameObjects/userInterface/notes/Strumline.hx",181,0xf50b2cbd)
HX_LOCAL_STACK_FRAME(_hx_pos_629eb1fb3c846ad3_188_push,"gameObjects.userInterface.notes.Strumline","push",0xf300fc44,"gameObjects.userInterface.notes.Strumline.push","gameObjects/userInterface/notes/Strumline.hx",188,0xf50b2cbd)
HX_LOCAL_STACK_FRAME(_hx_pos_629eb1fb3c846ad3_192_push,"gameObjects.userInterface.notes.Strumline","push",0xf300fc44,"gameObjects.userInterface.notes.Strumline.push","gameObjects/userInterface/notes/Strumline.hx",192,0xf50b2cbd)
namespace gameObjects{
namespace userInterface{
namespace notes{

void Strumline_obj::__construct(::hx::Null< Float >  __o_x, ::meta::state::PlayState playState, ::gameObjects::Character character, ::Dynamic __o_displayJudgements, ::Dynamic __o_autoplay, ::Dynamic __o_noteSplashes, ::Dynamic __o_keyAmount, ::Dynamic __o_downscroll, ::gameObjects::userInterface::notes::Strumline parent){
            		Float x = __o_x.Default(0);
            		 ::Dynamic displayJudgements = __o_displayJudgements;
            		if (::hx::IsNull(__o_displayJudgements)) displayJudgements = true;
            		 ::Dynamic autoplay = __o_autoplay;
            		if (::hx::IsNull(__o_autoplay)) autoplay = true;
            		 ::Dynamic noteSplashes = __o_noteSplashes;
            		if (::hx::IsNull(__o_noteSplashes)) noteSplashes = false;
            		 ::Dynamic keyAmount = __o_keyAmount;
            		if (::hx::IsNull(__o_keyAmount)) keyAmount = 4;
            		 ::Dynamic downscroll = __o_downscroll;
            		if (::hx::IsNull(__o_downscroll)) downscroll = false;
            	HX_GC_STACKFRAME(&_hx_pos_629eb1fb3c846ad3_124_new)
HXLINE( 134)		this->displayJudgements = false;
HXLINE( 131)		this->autoplay = true;
HXLINE( 139)		super::__construct(null());
HXLINE( 141)		this->receptors =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE( 142)		this->splashNotes =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE( 143)		this->notesGroup =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE( 145)		this->autoplay = ( (bool)(autoplay) );
HXLINE( 146)		this->character = character;
HXLINE( 147)		this->playState = playState;
HXLINE( 148)		this->displayJudgements = ( (bool)(displayJudgements) );
HXLINE( 150)		{
HXLINE( 150)			int _g = 0;
HXDLIN( 150)			 ::Dynamic _g1 = keyAmount;
HXDLIN( 150)			while(::hx::IsLess( _g,_g1 )){
HXLINE( 150)				_g = (_g + 1);
HXDLIN( 150)				int i = (_g - 1);
HXLINE( 152)				int staticArrow;
HXDLIN( 152)				if (( (bool)(downscroll) )) {
HXLINE( 152)					staticArrow = (::flixel::FlxG_obj::height - 200);
            				}
            				else {
HXLINE( 152)					staticArrow = 0;
            				}
HXDLIN( 152)				 ::gameObjects::userInterface::notes::UIStaticArrow staticArrow1 = ::ForeverAssets_obj::generateUIArrows((-25 + x),( (Float)((25 + staticArrow)) ),i,::meta::state::PlayState_obj::assetModifier);
HXLINE( 153)				staticArrow1->ID = i;
HXLINE( 155)				{
HXLINE( 155)					 ::gameObjects::userInterface::notes::UIStaticArrow _g1 = staticArrow1;
HXDLIN( 155)					_g1->set_x((_g1->x - ((( (Float)(keyAmount) ) / ( (Float)(2) )) * ::gameObjects::userInterface::notes::Note_obj::swagWidth)));
            				}
HXLINE( 156)				{
HXLINE( 156)					 ::gameObjects::userInterface::notes::UIStaticArrow _g2 = staticArrow1;
HXDLIN( 156)					_g2->set_x((_g2->x + (::gameObjects::userInterface::notes::Note_obj::swagWidth * ( (Float)(i) ))));
            				}
HXLINE( 157)				this->receptors->add(staticArrow1).StaticCast<  ::gameObjects::userInterface::notes::UIStaticArrow >();
HXLINE( 159)				staticArrow1->initialX = ::Math_obj::floor(staticArrow1->x);
HXLINE( 160)				staticArrow1->initialY = ::Math_obj::floor(staticArrow1->y);
HXLINE( 161)				staticArrow1->angleTo = ( (Float)(0) );
HXLINE( 162)				{
HXLINE( 162)					 ::gameObjects::userInterface::notes::UIStaticArrow _g3 = staticArrow1;
HXDLIN( 162)					_g3->set_y((_g3->y - ( (Float)(10) )));
            				}
HXLINE( 163)				staticArrow1->playAnim(HX_("static",ae,dc,fb,05),null(),null(),null());
HXLINE( 165)				staticArrow1->set_alpha(( (Float)(0) ));
HXLINE( 166)				::flixel::tweens::FlxTween_obj::tween(staticArrow1, ::Dynamic(::hx::Anon_obj::Create(2)
            					->setFixed(0,HX_("y",79,00,00,00),staticArrow1->initialY)
            					->setFixed(1,HX_("alpha",5e,a7,96,21),staticArrow1->setAlpha)),1, ::Dynamic(::hx::Anon_obj::Create(2)
            					->setFixed(0,HX_("startDelay",c1,af,3d,f3),(((Float)0.5) + (((Float)0.2) * ( (Float)(i) ))))
            					->setFixed(1,HX_("ease",ee,8b,0c,43),::flixel::tweens::FlxEase_obj::circOut_dyn())));
HXLINE( 168)				if (( (bool)(noteSplashes) )) {
HXLINE( 169)					 ::gameObjects::userInterface::notes::NoteSplash noteSplash = ::ForeverAssets_obj::generateNoteSplashes(HX_("noteSplashes",a7,57,29,8d),::meta::state::PlayState_obj::assetModifier,HX_("UI",54,4a,00,00),i);
HXLINE( 170)					this->splashNotes->add(noteSplash).StaticCast<  ::gameObjects::userInterface::notes::NoteSplash >();
            				}
            			}
            		}
HXLINE( 174)		this->add(this->receptors);
HXLINE( 175)		this->add(this->notesGroup);
HXLINE( 176)		if (::hx::IsNotNull( this->splashNotes )) {
HXLINE( 177)			this->add(this->splashNotes);
            		}
            	}

Dynamic Strumline_obj::__CreateEmpty() { return new Strumline_obj; }

void *Strumline_obj::_hx_vtable = 0;

Dynamic Strumline_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Strumline_obj > _hx_result = new Strumline_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8]);
	return _hx_result;
}

bool Strumline_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x7355e1f0) {
		if (inClassId<=(int)0x62817b24) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x62817b24;
		} else {
			return inClassId==(int)0x7355e1f0;
		}
	} else {
		return inClassId==(int)0x7ccf8994;
	}
}

void Strumline_obj::createSplash( ::gameObjects::userInterface::notes::Note coolNote){
            	HX_STACKFRAME(&_hx_pos_629eb1fb3c846ad3_181_createSplash)
HXLINE( 183)		::String noteSplashRandom = ::Std_obj::string((::flixel::FlxG_obj::random->_hx_int(0,1,null()) + 1));
HXLINE( 184)		Dynamic( this->splashNotes->members->__get(coolNote->noteData)).StaticCast<  ::gameObjects::userInterface::notes::NoteSplash >()->playAnim((HX_("anim",11,86,71,40) + noteSplashRandom),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(Strumline_obj,createSplash,(void))

void Strumline_obj::push( ::gameObjects::userInterface::notes::Note newNote){
            	HX_STACKFRAME(&_hx_pos_629eb1fb3c846ad3_188_push)
HXLINE( 190)		this->notesGroup->add(newNote).StaticCast<  ::gameObjects::userInterface::notes::Note >();
HXLINE( 192)		{
            			HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0,int,a1, ::Dynamic,_g) HXARGC(2)
            			int _hx_run( ::gameObjects::userInterface::notes::Note a2, ::gameObjects::userInterface::notes::Note a3){
            				HX_STACKFRAME(&_hx_pos_629eb1fb3c846ad3_192_push)
HXLINE( 192)				return ( (int)(_g(a1,a2,a3)) );
            			}
            			HX_END_LOCAL_FUNC2(return)

HXLINE( 192)			 ::flixel::group::FlxTypedGroup _this = this->notesGroup;
HXDLIN( 192)			int Order;
HXDLIN( 192)			if (!(( (bool)(::Init_obj::trueSettings->get(HX_("Downscroll",0f,4a,85,46))) ))) {
HXLINE( 192)				Order = 1;
            			}
            			else {
HXLINE( 192)				Order = -1;
            			}
HXDLIN( 192)			 ::Dynamic _g = ::flixel::util::FlxSort_obj::byY_dyn();
HXDLIN( 192)			int a1 = Order;
HXDLIN( 192)			 ::Dynamic _hx_tmp =  ::Dynamic(new _hx_Closure_0(a1,_g));
HXDLIN( 192)			_this->members->sort(_hx_tmp);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Strumline_obj,push,(void))


::hx::ObjectPtr< Strumline_obj > Strumline_obj::__new(::hx::Null< Float >  __o_x, ::meta::state::PlayState playState, ::gameObjects::Character character, ::Dynamic __o_displayJudgements, ::Dynamic __o_autoplay, ::Dynamic __o_noteSplashes, ::Dynamic __o_keyAmount, ::Dynamic __o_downscroll, ::gameObjects::userInterface::notes::Strumline parent) {
	::hx::ObjectPtr< Strumline_obj > __this = new Strumline_obj();
	__this->__construct(__o_x,playState,character,__o_displayJudgements,__o_autoplay,__o_noteSplashes,__o_keyAmount,__o_downscroll,parent);
	return __this;
}

::hx::ObjectPtr< Strumline_obj > Strumline_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_x, ::meta::state::PlayState playState, ::gameObjects::Character character, ::Dynamic __o_displayJudgements, ::Dynamic __o_autoplay, ::Dynamic __o_noteSplashes, ::Dynamic __o_keyAmount, ::Dynamic __o_downscroll, ::gameObjects::userInterface::notes::Strumline parent) {
	Strumline_obj *__this = (Strumline_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Strumline_obj), true, "gameObjects.userInterface.notes.Strumline"));
	*(void **)__this = Strumline_obj::_hx_vtable;
	__this->__construct(__o_x,playState,character,__o_displayJudgements,__o_autoplay,__o_noteSplashes,__o_keyAmount,__o_downscroll,parent);
	return __this;
}

Strumline_obj::Strumline_obj()
{
}

void Strumline_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Strumline);
	HX_MARK_MEMBER_NAME(receptors,"receptors");
	HX_MARK_MEMBER_NAME(splashNotes,"splashNotes");
	HX_MARK_MEMBER_NAME(notesGroup,"notesGroup");
	HX_MARK_MEMBER_NAME(autoplay,"autoplay");
	HX_MARK_MEMBER_NAME(character,"character");
	HX_MARK_MEMBER_NAME(playState,"playState");
	HX_MARK_MEMBER_NAME(displayJudgements,"displayJudgements");
	 ::flixel::group::FlxTypedGroup_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Strumline_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(receptors,"receptors");
	HX_VISIT_MEMBER_NAME(splashNotes,"splashNotes");
	HX_VISIT_MEMBER_NAME(notesGroup,"notesGroup");
	HX_VISIT_MEMBER_NAME(autoplay,"autoplay");
	HX_VISIT_MEMBER_NAME(character,"character");
	HX_VISIT_MEMBER_NAME(playState,"playState");
	HX_VISIT_MEMBER_NAME(displayJudgements,"displayJudgements");
	 ::flixel::group::FlxTypedGroup_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val Strumline_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"push") ) { return ::hx::Val( push_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"autoplay") ) { return ::hx::Val( autoplay ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"receptors") ) { return ::hx::Val( receptors ); }
		if (HX_FIELD_EQ(inName,"character") ) { return ::hx::Val( character ); }
		if (HX_FIELD_EQ(inName,"playState") ) { return ::hx::Val( playState ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"notesGroup") ) { return ::hx::Val( notesGroup ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"splashNotes") ) { return ::hx::Val( splashNotes ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"createSplash") ) { return ::hx::Val( createSplash_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"displayJudgements") ) { return ::hx::Val( displayJudgements ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Strumline_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"autoplay") ) { autoplay=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"receptors") ) { receptors=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		if (HX_FIELD_EQ(inName,"character") ) { character=inValue.Cast<  ::gameObjects::Character >(); return inValue; }
		if (HX_FIELD_EQ(inName,"playState") ) { playState=inValue.Cast<  ::meta::state::PlayState >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"notesGroup") ) { notesGroup=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"splashNotes") ) { splashNotes=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"displayJudgements") ) { displayJudgements=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Strumline_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("receptors",37,7d,22,c1));
	outFields->push(HX_("splashNotes",5a,55,ae,24));
	outFields->push(HX_("notesGroup",3e,3b,ac,91));
	outFields->push(HX_("autoplay",e3,f0,a6,42));
	outFields->push(HX_("character",a9,db,d1,41));
	outFields->push(HX_("playState",7d,a3,ef,a4));
	outFields->push(HX_("displayJudgements",00,67,3c,ab));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Strumline_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(Strumline_obj,receptors),HX_("receptors",37,7d,22,c1)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(Strumline_obj,splashNotes),HX_("splashNotes",5a,55,ae,24)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(Strumline_obj,notesGroup),HX_("notesGroup",3e,3b,ac,91)},
	{::hx::fsBool,(int)offsetof(Strumline_obj,autoplay),HX_("autoplay",e3,f0,a6,42)},
	{::hx::fsObject /*  ::gameObjects::Character */ ,(int)offsetof(Strumline_obj,character),HX_("character",a9,db,d1,41)},
	{::hx::fsObject /*  ::meta::state::PlayState */ ,(int)offsetof(Strumline_obj,playState),HX_("playState",7d,a3,ef,a4)},
	{::hx::fsBool,(int)offsetof(Strumline_obj,displayJudgements),HX_("displayJudgements",00,67,3c,ab)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Strumline_obj_sStaticStorageInfo = 0;
#endif

static ::String Strumline_obj_sMemberFields[] = {
	HX_("receptors",37,7d,22,c1),
	HX_("splashNotes",5a,55,ae,24),
	HX_("notesGroup",3e,3b,ac,91),
	HX_("autoplay",e3,f0,a6,42),
	HX_("character",a9,db,d1,41),
	HX_("playState",7d,a3,ef,a4),
	HX_("displayJudgements",00,67,3c,ab),
	HX_("createSplash",83,c1,ed,e1),
	HX_("push",da,11,61,4a),
	::String(null()) };

::hx::Class Strumline_obj::__mClass;

void Strumline_obj::__register()
{
	Strumline_obj _hx_dummy;
	Strumline_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("gameObjects.userInterface.notes.Strumline",44,8e,50,2f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Strumline_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Strumline_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Strumline_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Strumline_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace gameObjects
} // end namespace userInterface
} // end namespace notes
