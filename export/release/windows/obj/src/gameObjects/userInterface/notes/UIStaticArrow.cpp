// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_Init
#include <Init.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_gameObjects_userInterface_notes_UIStaticArrow
#include <gameObjects/userInterface/notes/UIStaticArrow.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_5124930895df8581_27_new,"gameObjects.userInterface.notes.UIStaticArrow","new",0x91368c60,"gameObjects.userInterface.notes.UIStaticArrow.new","gameObjects/userInterface/notes/Strumline.hx",27,0xf50b2cbd)
HX_LOCAL_STACK_FRAME(_hx_pos_5124930895df8581_63_playAnim,"gameObjects.userInterface.notes.UIStaticArrow","playAnim",0x4438ae25,"gameObjects.userInterface.notes.UIStaticArrow.playAnim","gameObjects/userInterface/notes/Strumline.hx",63,0xf50b2cbd)
HX_LOCAL_STACK_FRAME(_hx_pos_5124930895df8581_82_addOffset,"gameObjects.userInterface.notes.UIStaticArrow","addOffset",0x41fb8894,"gameObjects.userInterface.notes.UIStaticArrow.addOffset","gameObjects/userInterface/notes/Strumline.hx",82,0xf50b2cbd)
HX_LOCAL_STACK_FRAME(_hx_pos_5124930895df8581_85_getArrowFromNumber,"gameObjects.userInterface.notes.UIStaticArrow","getArrowFromNumber",0x4768e306,"gameObjects.userInterface.notes.UIStaticArrow.getArrowFromNumber","gameObjects/userInterface/notes/Strumline.hx",85,0xf50b2cbd)
HX_LOCAL_STACK_FRAME(_hx_pos_5124930895df8581_106_getColorFromNumber,"gameObjects.userInterface.notes.UIStaticArrow","getColorFromNumber",0x027d1f20,"gameObjects.userInterface.notes.UIStaticArrow.getColorFromNumber","gameObjects/userInterface/notes/Strumline.hx",106,0xf50b2cbd)
namespace gameObjects{
namespace userInterface{
namespace notes{

void UIStaticArrow_obj::__construct(Float x,Float y, ::Dynamic __o_babyArrowType){
            		 ::Dynamic babyArrowType = __o_babyArrowType;
            		if (::hx::IsNull(__o_babyArrowType)) babyArrowType = 0;
            	HX_GC_STACKFRAME(&_hx_pos_5124930895df8581_27_new)
HXLINE(  47)		Float _hx_tmp;
HXDLIN(  47)		if (( (bool)(::Init_obj::trueSettings->get(HX_("Opaque Arrows",e9,a3,c6,17))) )) {
HXLINE(  47)			_hx_tmp = ( (Float)(1) );
            		}
            		else {
HXLINE(  47)			_hx_tmp = ((Float)0.8);
            		}
HXDLIN(  47)		this->setAlpha = _hx_tmp;
HXLINE(  38)		this->canFinishAnimation = true;
HXLINE(  37)		this->babyArrowType = 0;
HXLINE(  52)		super::__construct(x,y,null());
HXLINE(  53)		this->animOffsets =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  55)		this->babyArrowType = ( (int)(babyArrowType) );
HXLINE(  57)		this->updateHitbox();
HXLINE(  58)		this->scrollFactor->set(null(),null());
            	}

Dynamic UIStaticArrow_obj::__CreateEmpty() { return new UIStaticArrow_obj; }

void *UIStaticArrow_obj::_hx_vtable = 0;

Dynamic UIStaticArrow_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< UIStaticArrow_obj > _hx_result = new UIStaticArrow_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool UIStaticArrow_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x4467c352) {
		if (inClassId<=(int)0x2c01639b) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2c01639b;
		} else {
			return inClassId==(int)0x4467c352;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void UIStaticArrow_obj::playAnim(::String AnimName,::hx::Null< bool >  __o_Force,::hx::Null< bool >  __o_Reversed,::hx::Null< int >  __o_Frame){
            		bool Force = __o_Force.Default(false);
            		bool Reversed = __o_Reversed.Default(false);
            		int Frame = __o_Frame.Default(0);
            	HX_STACKFRAME(&_hx_pos_5124930895df8581_63_playAnim)
HXLINE(  64)		if ((AnimName == HX_("confirm",00,9d,39,10))) {
HXLINE(  65)			this->set_alpha(( (Float)(1) ));
            		}
            		else {
HXLINE(  67)			this->set_alpha(this->setAlpha);
            		}
HXLINE(  69)		this->animation->play(AnimName,Force,Reversed,Frame);
HXLINE(  70)		this->updateHitbox();
HXLINE(  72)		::cpp::VirtualArray daOffset = ( (::cpp::VirtualArray)(this->animOffsets->get(AnimName)) );
HXLINE(  73)		if (this->animOffsets->exists(AnimName)) {
HXLINE(  75)			this->offset->set(daOffset->__get(0),daOffset->__get(1));
            		}
            		else {
HXLINE(  78)			this->offset->set(0,0);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(UIStaticArrow_obj,playAnim,(void))

void UIStaticArrow_obj::addOffset(::String name,::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y){
            		Float x = __o_x.Default(0);
            		Float y = __o_y.Default(0);
            	HX_STACKFRAME(&_hx_pos_5124930895df8581_82_addOffset)
HXDLIN(  82)		::cpp::VirtualArray v = ::Array_obj< Float >::__new(2)->init(0,x)->init(1,y);
HXDLIN(  82)		this->animOffsets->set(name,v);
            	}


HX_DEFINE_DYNAMIC_FUNC3(UIStaticArrow_obj,addOffset,(void))

::String UIStaticArrow_obj::getArrowFromNumber(int numb){
            	HX_STACKFRAME(&_hx_pos_5124930895df8581_85_getArrowFromNumber)
HXLINE(  88)		::String stringSect = HX_("",00,00,00,00);
HXLINE(  89)		switch((int)(numb)){
            			case (int)0: {
HXLINE(  92)				stringSect = HX_("left",07,08,b0,47);
            			}
            			break;
            			case (int)1: {
HXLINE(  94)				stringSect = HX_("down",62,f8,6d,42);
            			}
            			break;
            			case (int)2: {
HXLINE(  96)				stringSect = HX_("up",5b,66,00,00);
            			}
            			break;
            			case (int)3: {
HXLINE(  98)				stringSect = HX_("right",dc,0b,64,e9);
            			}
            			break;
            		}
HXLINE( 100)		return stringSect;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(UIStaticArrow_obj,getArrowFromNumber,return )

::String UIStaticArrow_obj::getColorFromNumber(int numb){
            	HX_STACKFRAME(&_hx_pos_5124930895df8581_106_getColorFromNumber)
HXLINE( 107)		::String stringSect = HX_("",00,00,00,00);
HXLINE( 108)		switch((int)(numb)){
            			case (int)0: {
HXLINE( 111)				stringSect = HX_("purple",3c,f6,89,71);
            			}
            			break;
            			case (int)1: {
HXLINE( 113)				stringSect = HX_("blue",9a,42,19,41);
            			}
            			break;
            			case (int)2: {
HXLINE( 115)				stringSect = HX_("green",c3,0e,ed,99);
            			}
            			break;
            			case (int)3: {
HXLINE( 117)				stringSect = HX_("red",51,d9,56,00);
            			}
            			break;
            		}
HXLINE( 119)		return stringSect;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(UIStaticArrow_obj,getColorFromNumber,return )


::hx::ObjectPtr< UIStaticArrow_obj > UIStaticArrow_obj::__new(Float x,Float y, ::Dynamic __o_babyArrowType) {
	::hx::ObjectPtr< UIStaticArrow_obj > __this = new UIStaticArrow_obj();
	__this->__construct(x,y,__o_babyArrowType);
	return __this;
}

::hx::ObjectPtr< UIStaticArrow_obj > UIStaticArrow_obj::__alloc(::hx::Ctx *_hx_ctx,Float x,Float y, ::Dynamic __o_babyArrowType) {
	UIStaticArrow_obj *__this = (UIStaticArrow_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(UIStaticArrow_obj), true, "gameObjects.userInterface.notes.UIStaticArrow"));
	*(void **)__this = UIStaticArrow_obj::_hx_vtable;
	__this->__construct(x,y,__o_babyArrowType);
	return __this;
}

UIStaticArrow_obj::UIStaticArrow_obj()
{
}

void UIStaticArrow_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(UIStaticArrow);
	HX_MARK_MEMBER_NAME(animOffsets,"animOffsets");
	HX_MARK_MEMBER_NAME(babyArrowType,"babyArrowType");
	HX_MARK_MEMBER_NAME(canFinishAnimation,"canFinishAnimation");
	HX_MARK_MEMBER_NAME(initialX,"initialX");
	HX_MARK_MEMBER_NAME(initialY,"initialY");
	HX_MARK_MEMBER_NAME(xTo,"xTo");
	HX_MARK_MEMBER_NAME(yTo,"yTo");
	HX_MARK_MEMBER_NAME(angleTo,"angleTo");
	HX_MARK_MEMBER_NAME(setAlpha,"setAlpha");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void UIStaticArrow_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(animOffsets,"animOffsets");
	HX_VISIT_MEMBER_NAME(babyArrowType,"babyArrowType");
	HX_VISIT_MEMBER_NAME(canFinishAnimation,"canFinishAnimation");
	HX_VISIT_MEMBER_NAME(initialX,"initialX");
	HX_VISIT_MEMBER_NAME(initialY,"initialY");
	HX_VISIT_MEMBER_NAME(xTo,"xTo");
	HX_VISIT_MEMBER_NAME(yTo,"yTo");
	HX_VISIT_MEMBER_NAME(angleTo,"angleTo");
	HX_VISIT_MEMBER_NAME(setAlpha,"setAlpha");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val UIStaticArrow_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"xTo") ) { return ::hx::Val( xTo ); }
		if (HX_FIELD_EQ(inName,"yTo") ) { return ::hx::Val( yTo ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"angleTo") ) { return ::hx::Val( angleTo ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"initialX") ) { return ::hx::Val( initialX ); }
		if (HX_FIELD_EQ(inName,"initialY") ) { return ::hx::Val( initialY ); }
		if (HX_FIELD_EQ(inName,"setAlpha") ) { return ::hx::Val( setAlpha ); }
		if (HX_FIELD_EQ(inName,"playAnim") ) { return ::hx::Val( playAnim_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"addOffset") ) { return ::hx::Val( addOffset_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"animOffsets") ) { return ::hx::Val( animOffsets ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"babyArrowType") ) { return ::hx::Val( babyArrowType ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"canFinishAnimation") ) { return ::hx::Val( canFinishAnimation ); }
	}
	return super::__Field(inName,inCallProp);
}

bool UIStaticArrow_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 18:
		if (HX_FIELD_EQ(inName,"getArrowFromNumber") ) { outValue = getArrowFromNumber_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getColorFromNumber") ) { outValue = getColorFromNumber_dyn(); return true; }
	}
	return false;
}

::hx::Val UIStaticArrow_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"xTo") ) { xTo=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"yTo") ) { yTo=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"angleTo") ) { angleTo=inValue.Cast< Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"initialX") ) { initialX=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"initialY") ) { initialY=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"setAlpha") ) { setAlpha=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"animOffsets") ) { animOffsets=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"babyArrowType") ) { babyArrowType=inValue.Cast< int >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"canFinishAnimation") ) { canFinishAnimation=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void UIStaticArrow_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("animOffsets",6f,ff,7a,f8));
	outFields->push(HX_("babyArrowType",ed,dc,0f,80));
	outFields->push(HX_("canFinishAnimation",01,12,0b,c7));
	outFields->push(HX_("initialX",54,63,8f,5f));
	outFields->push(HX_("initialY",55,63,8f,5f));
	outFields->push(HX_("xTo",13,58,5b,00));
	outFields->push(HX_("yTo",54,1a,5c,00));
	outFields->push(HX_("angleTo",2e,68,d9,52));
	outFields->push(HX_("setAlpha",5c,10,cb,2f));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo UIStaticArrow_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(UIStaticArrow_obj,animOffsets),HX_("animOffsets",6f,ff,7a,f8)},
	{::hx::fsInt,(int)offsetof(UIStaticArrow_obj,babyArrowType),HX_("babyArrowType",ed,dc,0f,80)},
	{::hx::fsBool,(int)offsetof(UIStaticArrow_obj,canFinishAnimation),HX_("canFinishAnimation",01,12,0b,c7)},
	{::hx::fsInt,(int)offsetof(UIStaticArrow_obj,initialX),HX_("initialX",54,63,8f,5f)},
	{::hx::fsInt,(int)offsetof(UIStaticArrow_obj,initialY),HX_("initialY",55,63,8f,5f)},
	{::hx::fsFloat,(int)offsetof(UIStaticArrow_obj,xTo),HX_("xTo",13,58,5b,00)},
	{::hx::fsFloat,(int)offsetof(UIStaticArrow_obj,yTo),HX_("yTo",54,1a,5c,00)},
	{::hx::fsFloat,(int)offsetof(UIStaticArrow_obj,angleTo),HX_("angleTo",2e,68,d9,52)},
	{::hx::fsFloat,(int)offsetof(UIStaticArrow_obj,setAlpha),HX_("setAlpha",5c,10,cb,2f)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *UIStaticArrow_obj_sStaticStorageInfo = 0;
#endif

static ::String UIStaticArrow_obj_sMemberFields[] = {
	HX_("animOffsets",6f,ff,7a,f8),
	HX_("babyArrowType",ed,dc,0f,80),
	HX_("canFinishAnimation",01,12,0b,c7),
	HX_("initialX",54,63,8f,5f),
	HX_("initialY",55,63,8f,5f),
	HX_("xTo",13,58,5b,00),
	HX_("yTo",54,1a,5c,00),
	HX_("angleTo",2e,68,d9,52),
	HX_("setAlpha",5c,10,cb,2f),
	HX_("playAnim",25,ea,84,30),
	HX_("addOffset",94,cc,63,18),
	::String(null()) };

::hx::Class UIStaticArrow_obj::__mClass;

static ::String UIStaticArrow_obj_sStaticFields[] = {
	HX_("getArrowFromNumber",06,1f,d8,2b),
	HX_("getColorFromNumber",20,5b,ec,e6),
	::String(null())
};

void UIStaticArrow_obj::__register()
{
	UIStaticArrow_obj _hx_dummy;
	UIStaticArrow_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("gameObjects.userInterface.notes.UIStaticArrow",6e,1c,a9,5b);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &UIStaticArrow_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(UIStaticArrow_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(UIStaticArrow_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< UIStaticArrow_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = UIStaticArrow_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = UIStaticArrow_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace gameObjects
} // end namespace userInterface
} // end namespace notes
