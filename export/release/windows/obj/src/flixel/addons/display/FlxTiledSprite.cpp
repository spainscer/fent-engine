// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxStrip
#include <flixel/FlxStrip.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxTiledSprite
#include <flixel/addons/display/FlxTiledSprite.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxImageFrame
#include <flixel/graphics/frames/FlxImageFrame.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_BitmapFrontEnd
#include <flixel/system/frontEnds/BitmapFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSpriteUtil
#include <flixel/util/FlxSpriteUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_openfl__Vector_FloatVector
#include <openfl/_Vector/FloatVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IntVector
#include <openfl/_Vector/IntVector.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_18_new,"flixel.addons.display.FlxTiledSprite","new",0xa67e7010,"flixel.addons.display.FlxTiledSprite.new","flixel/addons/display/FlxTiledSprite.hx",18,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_91_destroy,"flixel.addons.display.FlxTiledSprite","destroy",0x347264aa,"flixel.addons.display.FlxTiledSprite.destroy","flixel/addons/display/FlxTiledSprite.hx",91,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_98_loadGraphic,"flixel.addons.display.FlxTiledSprite","loadGraphic",0x1afee8d2,"flixel.addons.display.FlxTiledSprite.loadGraphic","flixel/addons/display/FlxTiledSprite.hx",98,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_104_loadFrame,"flixel.addons.display.FlxTiledSprite","loadFrame",0x2ee847d7,"flixel.addons.display.FlxTiledSprite.loadFrame","flixel/addons/display/FlxTiledSprite.hx",104,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_110_set_graphic,"flixel.addons.display.FlxTiledSprite","set_graphic",0xdac8917b,"flixel.addons.display.FlxTiledSprite.set_graphic","flixel/addons/display/FlxTiledSprite.hx",110,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_118_regenGraphic,"flixel.addons.display.FlxTiledSprite","regenGraphic",0x43753fbb,"flixel.addons.display.FlxTiledSprite.regenGraphic","flixel/addons/display/FlxTiledSprite.hx",118,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_135_draw,"flixel.addons.display.FlxTiledSprite","draw",0x01914654,"flixel.addons.display.FlxTiledSprite.draw","flixel/addons/display/FlxTiledSprite.hx",135,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_157_updateRenderSprite,"flixel.addons.display.FlxTiledSprite","updateRenderSprite",0x5eb5a1f4,"flixel.addons.display.FlxTiledSprite.updateRenderSprite","flixel/addons/display/FlxTiledSprite.hx",157,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_212_updateVerticesData,"flixel.addons.display.FlxTiledSprite","updateVerticesData",0xd92df4bc,"flixel.addons.display.FlxTiledSprite.updateVerticesData","flixel/addons/display/FlxTiledSprite.hx",212,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_267_set_width,"flixel.addons.display.FlxTiledSprite","set_width",0xfe8a8219,"flixel.addons.display.FlxTiledSprite.set_width","flixel/addons/display/FlxTiledSprite.hx",267,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_278_set_height,"flixel.addons.display.FlxTiledSprite","set_height",0x70f6cc74,"flixel.addons.display.FlxTiledSprite.set_height","flixel/addons/display/FlxTiledSprite.hx",278,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_289_set_scrollX,"flixel.addons.display.FlxTiledSprite","set_scrollX",0x97996a7e,"flixel.addons.display.FlxTiledSprite.set_scrollX","flixel/addons/display/FlxTiledSprite.hx",289,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_297_set_scrollY,"flixel.addons.display.FlxTiledSprite","set_scrollY",0x97996a7f,"flixel.addons.display.FlxTiledSprite.set_scrollY","flixel/addons/display/FlxTiledSprite.hx",297,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_305_set_repeatX,"flixel.addons.display.FlxTiledSprite","set_repeatX",0x0d490f70,"flixel.addons.display.FlxTiledSprite.set_repeatX","flixel/addons/display/FlxTiledSprite.hx",305,0xeabb3a1f)
HX_LOCAL_STACK_FRAME(_hx_pos_9c4135b7a1fcedcd_313_set_repeatY,"flixel.addons.display.FlxTiledSprite","set_repeatY",0x0d490f71,"flixel.addons.display.FlxTiledSprite.set_repeatY","flixel/addons/display/FlxTiledSprite.hx",313,0xeabb3a1f)
namespace flixel{
namespace addons{
namespace display{

void FlxTiledSprite_obj::__construct( ::Dynamic Graphic,Float Width,Float Height,::hx::Null< bool >  __o_RepeatX,::hx::Null< bool >  __o_RepeatY){
            		bool RepeatX = __o_RepeatX.Default(true);
            		bool RepeatY = __o_RepeatY.Default(true);
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_18_new)
HXLINE(  47)		this->graphicVisible = true;
HXLINE(  45)		this->regen = true;
HXLINE(  38)		this->repeatY = true;
HXLINE(  33)		this->repeatX = true;
HXLINE(  28)		this->scrollY = ((Float)0);
HXLINE(  23)		this->scrollX = ((Float)0);
HXLINE(  51)		super::__construct(null(),null(),null());
HXLINE(  53)		this->repeat = true;
HXLINE(  55)		this->indices->set(0,0);
HXLINE(  56)		this->indices->set(1,1);
HXLINE(  57)		this->indices->set(2,2);
HXLINE(  58)		this->indices->set(3,2);
HXLINE(  59)		this->indices->set(4,3);
HXLINE(  60)		this->indices->set(5,0);
HXLINE(  62)		this->uvtData->set(0,( (Float)(0) ));
HXLINE(  63)		this->uvtData->set(1,( (Float)(0) ));
HXLINE(  64)		this->uvtData->set(2,( (Float)(1) ));
HXLINE(  65)		this->uvtData->set(3,( (Float)(0) ));
HXLINE(  66)		this->uvtData->set(4,( (Float)(1) ));
HXLINE(  67)		this->uvtData->set(5,( (Float)(1) ));
HXLINE(  68)		this->uvtData->set(6,( (Float)(0) ));
HXLINE(  69)		this->uvtData->set(7,( (Float)(1) ));
HXLINE(  71)		this->vertices->set(0,( (Float)(0) ));
HXLINE(  72)		this->vertices->set(1,( (Float)(0) ));
HXLINE(  73)		this->vertices->set(2,Width);
HXLINE(  74)		this->vertices->set(3,( (Float)(0) ));
HXLINE(  75)		this->vertices->set(4,Width);
HXLINE(  76)		this->vertices->set(5,Height);
HXLINE(  77)		this->vertices->set(6,( (Float)(0) ));
HXLINE(  78)		this->vertices->set(7,Height);
HXLINE(  80)		this->set_width(Width);
HXLINE(  81)		this->set_height(Height);
HXLINE(  83)		this->set_repeatX(RepeatX);
HXLINE(  84)		this->set_repeatY(RepeatY);
HXLINE(  86)		if (::hx::IsNotNull( Graphic )) {
HXLINE(  87)			this->loadGraphic(Graphic,null(),null(),null(),null(),null());
            		}
            	}

Dynamic FlxTiledSprite_obj::__CreateEmpty() { return new FlxTiledSprite_obj; }

void *FlxTiledSprite_obj::_hx_vtable = 0;

Dynamic FlxTiledSprite_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxTiledSprite_obj > _hx_result = new FlxTiledSprite_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4]);
	return _hx_result;
}

bool FlxTiledSprite_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x7c863966) {
		if (inClassId<=(int)0x2c01639b) {
			if (inClassId<=(int)0x16cfa598) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x16cfa598;
			} else {
				return inClassId==(int)0x2c01639b;
			}
		} else {
			return inClassId==(int)0x7c863966;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void FlxTiledSprite_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_91_destroy)
HXLINE(  92)		this->renderSprite = ( ( ::flixel::FlxSprite)(::flixel::util::FlxDestroyUtil_obj::destroy(this->renderSprite)) );
HXLINE(  93)		this->super::destroy();
            	}


 ::flixel::FlxSprite FlxTiledSprite_obj::loadGraphic( ::Dynamic Graphic,::hx::Null< bool >  __o_Animated,::hx::Null< int >  __o_Width,::hx::Null< int >  __o_Height,::hx::Null< bool >  __o_Unique,::String Key){
            		bool Animated = __o_Animated.Default(false);
            		int Width = __o_Width.Default(0);
            		int Height = __o_Height.Default(0);
            		bool Unique = __o_Unique.Default(false);
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_98_loadGraphic)
HXLINE(  99)		this->set_graphic(::flixel::FlxG_obj::bitmap->add(Graphic,null(),null()));
HXLINE( 100)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


 ::flixel::addons::display::FlxTiledSprite FlxTiledSprite_obj::loadFrame( ::flixel::graphics::frames::FlxFrame Frame){
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_104_loadFrame)
HXLINE( 105)		this->set_graphic(::flixel::graphics::FlxGraphic_obj::fromFrame(Frame,null(),null(),null()));
HXLINE( 106)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTiledSprite_obj,loadFrame,return )

 ::flixel::graphics::FlxGraphic FlxTiledSprite_obj::set_graphic( ::flixel::graphics::FlxGraphic Value){
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_110_set_graphic)
HXLINE( 111)		if (::hx::IsNotEq( this->graphic,Value )) {
HXLINE( 112)			this->regen = true;
            		}
HXLINE( 114)		return this->super::set_graphic(Value);
            	}


void FlxTiledSprite_obj::regenGraphic(){
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_118_regenGraphic)
HXLINE( 119)		bool _hx_tmp;
HXDLIN( 119)		if (this->regen) {
HXLINE( 119)			_hx_tmp = ::hx::IsNull( this->graphic );
            		}
            		else {
HXLINE( 119)			_hx_tmp = true;
            		}
HXDLIN( 119)		if (_hx_tmp) {
HXLINE( 120)			return;
            		}
HXLINE( 122)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 124)			this->updateRenderSprite();
            		}
            		else {
HXLINE( 128)			this->updateVerticesData();
            		}
HXLINE( 131)		this->regen = false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTiledSprite_obj,regenGraphic,(void))

void FlxTiledSprite_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_135_draw)
HXLINE( 136)		if (this->regen) {
HXLINE( 137)			this->regenGraphic();
            		}
HXLINE( 139)		if (!(this->graphicVisible)) {
HXLINE( 140)			return;
            		}
HXLINE( 142)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 144)			this->renderSprite->set_x(this->x);
HXLINE( 145)			this->renderSprite->set_y(this->y);
HXLINE( 146)			this->renderSprite->scrollFactor->set(this->scrollFactor->x,this->scrollFactor->y);
HXLINE( 147)			 ::flixel::FlxSprite _hx_tmp = this->renderSprite;
HXDLIN( 147)			_hx_tmp->set_cameras(this->get_cameras());
HXLINE( 148)			this->renderSprite->draw();
            		}
            		else {
HXLINE( 152)			this->super::draw();
            		}
            	}


void FlxTiledSprite_obj::updateRenderSprite(){
            	HX_GC_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_157_updateRenderSprite)
HXLINE( 158)		this->graphicVisible = true;
HXLINE( 160)		if (::hx::IsNull( this->renderSprite )) {
HXLINE( 161)			this->renderSprite =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
            		}
HXLINE( 163)		Float rectX;
HXDLIN( 163)		if (this->repeatX) {
HXLINE( 163)			rectX = ( (Float)(0) );
            		}
            		else {
HXLINE( 163)			rectX = this->scrollX;
            		}
HXLINE( 164)		Float rectWidth;
HXDLIN( 164)		if (this->repeatX) {
HXLINE( 164)			rectWidth = this->get_width();
            		}
            		else {
HXLINE( 164)			rectWidth = ( (Float)(this->graphic->bitmap->width) );
            		}
HXLINE( 166)		bool _hx_tmp;
HXDLIN( 166)		if (!(this->repeatX)) {
HXLINE( 166)			if (!((rectX > this->get_width()))) {
HXLINE( 166)				_hx_tmp = ((rectX + rectWidth) < 0);
            			}
            			else {
HXLINE( 166)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE( 166)			_hx_tmp = false;
            		}
HXDLIN( 166)		if (_hx_tmp) {
HXLINE( 168)			this->graphicVisible = false;
HXLINE( 169)			return;
            		}
HXLINE( 172)		Float rectY;
HXDLIN( 172)		if (this->repeatY) {
HXLINE( 172)			rectY = ( (Float)(0) );
            		}
            		else {
HXLINE( 172)			rectY = this->scrollY;
            		}
HXLINE( 173)		Float rectHeight;
HXDLIN( 173)		if (this->repeatY) {
HXLINE( 173)			rectHeight = this->get_height();
            		}
            		else {
HXLINE( 173)			rectHeight = ( (Float)(this->graphic->bitmap->height) );
            		}
HXLINE( 175)		bool _hx_tmp1;
HXDLIN( 175)		if (!(this->repeatY)) {
HXLINE( 175)			if (!((rectY > this->get_height()))) {
HXLINE( 175)				_hx_tmp1 = ((rectY + rectHeight) < 0);
            			}
            			else {
HXLINE( 175)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXLINE( 175)			_hx_tmp1 = false;
            		}
HXDLIN( 175)		if (_hx_tmp1) {
HXLINE( 177)			this->graphicVisible = false;
HXLINE( 178)			return;
            		}
HXLINE( 181)		bool _hx_tmp2;
HXDLIN( 181)		Float _hx_tmp3 = this->renderSprite->get_width();
HXDLIN( 181)		if ((_hx_tmp3 == this->get_width())) {
HXLINE( 181)			Float _hx_tmp = this->renderSprite->get_height();
HXDLIN( 181)			_hx_tmp2 = (_hx_tmp != this->get_height());
            		}
            		else {
HXLINE( 181)			_hx_tmp2 = true;
            		}
HXDLIN( 181)		if (_hx_tmp2) {
HXLINE( 183)			 ::flixel::FlxSprite _hx_tmp = this->renderSprite;
HXDLIN( 183)			int _hx_tmp1 = ::Std_obj::_hx_int(this->get_width());
HXDLIN( 183)			_hx_tmp->makeGraphic(_hx_tmp1,::Std_obj::_hx_int(this->get_height()),0,true,null());
            		}
            		else {
HXLINE( 187)			 ::openfl::geom::Rectangle _hx_tmp = this->_flashRect2;
HXDLIN( 187)			Float _hx_tmp1 = this->get_width();
HXDLIN( 187)			_hx_tmp->setTo(( (Float)(0) ),( (Float)(0) ),_hx_tmp1,this->get_height());
HXLINE( 188)			this->renderSprite->get_pixels()->fillRect(this->_flashRect2,0);
            		}
HXLINE( 191)		::flixel::util::FlxSpriteUtil_obj::flashGfx->clear();
HXLINE( 193)		bool _hx_tmp4;
HXDLIN( 193)		if ((this->scrollX == 0)) {
HXLINE( 193)			_hx_tmp4 = (this->scrollY != 0);
            		}
            		else {
HXLINE( 193)			_hx_tmp4 = true;
            		}
HXDLIN( 193)		if (_hx_tmp4) {
HXLINE( 195)			this->_matrix->identity();
HXLINE( 196)			this->_matrix->tx = ( (Float)(::Math_obj::round(this->scrollX)) );
HXLINE( 197)			this->_matrix->ty = ( (Float)(::Math_obj::round(this->scrollY)) );
HXLINE( 198)			::flixel::util::FlxSpriteUtil_obj::flashGfx->beginBitmapFill(this->graphic->bitmap,this->_matrix,null(),null());
            		}
            		else {
HXLINE( 202)			::flixel::util::FlxSpriteUtil_obj::flashGfx->beginBitmapFill(this->graphic->bitmap,null(),null(),null());
            		}
HXLINE( 205)		::flixel::util::FlxSpriteUtil_obj::flashGfx->drawRect(rectX,rectY,rectWidth,rectHeight);
HXLINE( 206)		this->renderSprite->get_pixels()->draw(::flixel::util::FlxSpriteUtil_obj::flashGfxSprite,null(),this->colorTransform,null(),null(),null());
HXLINE( 207)		::flixel::util::FlxSpriteUtil_obj::flashGfx->clear();
HXLINE( 208)		this->renderSprite->dirty = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTiledSprite_obj,updateRenderSprite,(void))

void FlxTiledSprite_obj::updateVerticesData(){
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_212_updateVerticesData)
HXLINE( 213)		if (::hx::IsNull( this->graphic )) {
HXLINE( 214)			return;
            		}
HXLINE( 216)		 ::flixel::graphics::frames::FlxFrame frame = this->graphic->get_imageFrame()->get_frame();
HXLINE( 217)		this->graphicVisible = true;
HXLINE( 219)		if (this->repeatX) {
HXLINE( 221)			{
HXLINE( 221)				::Dynamic this1 = this->vertices;
HXDLIN( 221)				( ( ::openfl::_Vector::FloatVector)(this1) )->set(0,this->vertices->set(6,((Float)0.0)));
            			}
HXLINE( 222)			{
HXLINE( 222)				::Dynamic this2 = this->vertices;
HXDLIN( 222)				::Dynamic this3 = this->vertices;
HXDLIN( 222)				( ( ::openfl::_Vector::FloatVector)(this2) )->set(2,( ( ::openfl::_Vector::FloatVector)(this3) )->set(4,this->get_width()));
            			}
HXLINE( 224)			{
HXLINE( 224)				::Dynamic this4 = this->uvtData;
HXDLIN( 224)				( ( ::openfl::_Vector::FloatVector)(this4) )->set(0,this->uvtData->set(6,(-(this->scrollX) / frame->sourceSize->x)));
            			}
HXLINE( 225)			{
HXLINE( 225)				::Dynamic this5 = this->uvtData;
HXDLIN( 225)				::Dynamic this6 = this->uvtData;
HXDLIN( 225)				Float value = this->uvtData->get(0);
HXDLIN( 225)				Float value1 = this->get_width();
HXDLIN( 225)				( ( ::openfl::_Vector::FloatVector)(this5) )->set(2,( ( ::openfl::_Vector::FloatVector)(this6) )->set(4,(value + (value1 / frame->sourceSize->x))));
            			}
            		}
            		else {
HXLINE( 229)			{
HXLINE( 229)				::Dynamic this1 = this->vertices;
HXDLIN( 229)				::Dynamic this2 = this->vertices;
HXDLIN( 229)				Float Value = this->scrollX;
HXDLIN( 229)				 ::Dynamic Max = this->get_width();
HXDLIN( 229)				Float lowerBound;
HXDLIN( 229)				if ((Value < 0)) {
HXLINE( 229)					lowerBound = ( (Float)(0) );
            				}
            				else {
HXLINE( 229)					lowerBound = Value;
            				}
HXDLIN( 229)				Float value;
HXDLIN( 229)				bool value1;
HXDLIN( 229)				if (::hx::IsNotNull( Max )) {
HXLINE( 229)					value1 = ::hx::IsGreater( lowerBound,Max );
            				}
            				else {
HXLINE( 229)					value1 = false;
            				}
HXDLIN( 229)				if (value1) {
HXLINE( 229)					value = ( (Float)(Max) );
            				}
            				else {
HXLINE( 229)					value = lowerBound;
            				}
HXDLIN( 229)				( ( ::openfl::_Vector::FloatVector)(this1) )->set(0,( ( ::openfl::_Vector::FloatVector)(this2) )->set(6,value));
            			}
HXLINE( 230)			{
HXLINE( 230)				::Dynamic this3 = this->vertices;
HXDLIN( 230)				::Dynamic this4 = this->vertices;
HXDLIN( 230)				Float Value1 = (this->scrollX + frame->sourceSize->x);
HXDLIN( 230)				 ::Dynamic Max1 = this->get_width();
HXDLIN( 230)				Float lowerBound1;
HXDLIN( 230)				if ((Value1 < 0)) {
HXLINE( 230)					lowerBound1 = ( (Float)(0) );
            				}
            				else {
HXLINE( 230)					lowerBound1 = Value1;
            				}
HXDLIN( 230)				Float value2;
HXDLIN( 230)				bool value3;
HXDLIN( 230)				if (::hx::IsNotNull( Max1 )) {
HXLINE( 230)					value3 = ::hx::IsGreater( lowerBound1,Max1 );
            				}
            				else {
HXLINE( 230)					value3 = false;
            				}
HXDLIN( 230)				if (value3) {
HXLINE( 230)					value2 = ( (Float)(Max1) );
            				}
            				else {
HXLINE( 230)					value2 = lowerBound1;
            				}
HXDLIN( 230)				( ( ::openfl::_Vector::FloatVector)(this3) )->set(2,( ( ::openfl::_Vector::FloatVector)(this4) )->set(4,value2));
            			}
HXLINE( 232)			Float _hx_tmp = this->vertices->get(2);
HXDLIN( 232)			if (((_hx_tmp - this->vertices->get(0)) <= 0)) {
HXLINE( 234)				this->graphicVisible = false;
HXLINE( 235)				return;
            			}
HXLINE( 238)			{
HXLINE( 238)				::Dynamic this5 = this->uvtData;
HXDLIN( 238)				::Dynamic this6 = this->uvtData;
HXDLIN( 238)				Float value4 = this->vertices->get(0);
HXDLIN( 238)				( ( ::openfl::_Vector::FloatVector)(this5) )->set(0,( ( ::openfl::_Vector::FloatVector)(this6) )->set(6,((value4 - this->scrollX) / frame->sourceSize->x)));
            			}
HXLINE( 239)			{
HXLINE( 239)				::Dynamic this7 = this->uvtData;
HXDLIN( 239)				::Dynamic this8 = this->uvtData;
HXDLIN( 239)				Float value5 = this->uvtData->get(0);
HXDLIN( 239)				Float value6 = this->vertices->get(2);
HXDLIN( 239)				Float value7 = (value6 - this->vertices->get(0));
HXDLIN( 239)				( ( ::openfl::_Vector::FloatVector)(this7) )->set(2,( ( ::openfl::_Vector::FloatVector)(this8) )->set(4,(value5 + (value7 / frame->sourceSize->x))));
            			}
            		}
HXLINE( 242)		if (this->repeatY) {
HXLINE( 244)			{
HXLINE( 244)				::Dynamic this1 = this->vertices;
HXDLIN( 244)				( ( ::openfl::_Vector::FloatVector)(this1) )->set(1,this->vertices->set(3,((Float)0.0)));
            			}
HXLINE( 245)			{
HXLINE( 245)				::Dynamic this2 = this->vertices;
HXDLIN( 245)				::Dynamic this3 = this->vertices;
HXDLIN( 245)				( ( ::openfl::_Vector::FloatVector)(this2) )->set(5,( ( ::openfl::_Vector::FloatVector)(this3) )->set(7,this->get_height()));
            			}
HXLINE( 247)			{
HXLINE( 247)				::Dynamic this4 = this->uvtData;
HXDLIN( 247)				( ( ::openfl::_Vector::FloatVector)(this4) )->set(1,this->uvtData->set(3,(-(this->scrollY) / frame->sourceSize->y)));
            			}
HXLINE( 248)			{
HXLINE( 248)				::Dynamic this5 = this->uvtData;
HXDLIN( 248)				::Dynamic this6 = this->uvtData;
HXDLIN( 248)				Float value = this->uvtData->get(1);
HXDLIN( 248)				Float value1 = this->get_height();
HXDLIN( 248)				( ( ::openfl::_Vector::FloatVector)(this5) )->set(5,( ( ::openfl::_Vector::FloatVector)(this6) )->set(7,(value + (value1 / frame->sourceSize->y))));
            			}
            		}
            		else {
HXLINE( 252)			{
HXLINE( 252)				::Dynamic this1 = this->vertices;
HXDLIN( 252)				::Dynamic this2 = this->vertices;
HXDLIN( 252)				Float Value = this->scrollY;
HXDLIN( 252)				 ::Dynamic Max = this->get_height();
HXDLIN( 252)				Float lowerBound;
HXDLIN( 252)				if ((Value < 0)) {
HXLINE( 252)					lowerBound = ( (Float)(0) );
            				}
            				else {
HXLINE( 252)					lowerBound = Value;
            				}
HXDLIN( 252)				Float value;
HXDLIN( 252)				bool value1;
HXDLIN( 252)				if (::hx::IsNotNull( Max )) {
HXLINE( 252)					value1 = ::hx::IsGreater( lowerBound,Max );
            				}
            				else {
HXLINE( 252)					value1 = false;
            				}
HXDLIN( 252)				if (value1) {
HXLINE( 252)					value = ( (Float)(Max) );
            				}
            				else {
HXLINE( 252)					value = lowerBound;
            				}
HXDLIN( 252)				( ( ::openfl::_Vector::FloatVector)(this1) )->set(1,( ( ::openfl::_Vector::FloatVector)(this2) )->set(3,value));
            			}
HXLINE( 253)			{
HXLINE( 253)				::Dynamic this3 = this->vertices;
HXDLIN( 253)				::Dynamic this4 = this->vertices;
HXDLIN( 253)				Float Value1 = (this->scrollY + frame->sourceSize->y);
HXDLIN( 253)				 ::Dynamic Max1 = this->get_height();
HXDLIN( 253)				Float lowerBound1;
HXDLIN( 253)				if ((Value1 < 0)) {
HXLINE( 253)					lowerBound1 = ( (Float)(0) );
            				}
            				else {
HXLINE( 253)					lowerBound1 = Value1;
            				}
HXDLIN( 253)				Float value2;
HXDLIN( 253)				bool value3;
HXDLIN( 253)				if (::hx::IsNotNull( Max1 )) {
HXLINE( 253)					value3 = ::hx::IsGreater( lowerBound1,Max1 );
            				}
            				else {
HXLINE( 253)					value3 = false;
            				}
HXDLIN( 253)				if (value3) {
HXLINE( 253)					value2 = ( (Float)(Max1) );
            				}
            				else {
HXLINE( 253)					value2 = lowerBound1;
            				}
HXDLIN( 253)				( ( ::openfl::_Vector::FloatVector)(this3) )->set(5,( ( ::openfl::_Vector::FloatVector)(this4) )->set(7,value2));
            			}
HXLINE( 255)			Float _hx_tmp = this->vertices->get(5);
HXDLIN( 255)			if (((_hx_tmp - this->vertices->get(1)) <= 0)) {
HXLINE( 257)				this->graphicVisible = false;
HXLINE( 258)				return;
            			}
HXLINE( 261)			{
HXLINE( 261)				::Dynamic this5 = this->uvtData;
HXDLIN( 261)				::Dynamic this6 = this->uvtData;
HXDLIN( 261)				Float value4 = this->vertices->get(1);
HXDLIN( 261)				( ( ::openfl::_Vector::FloatVector)(this5) )->set(1,( ( ::openfl::_Vector::FloatVector)(this6) )->set(3,((value4 - this->scrollY) / frame->sourceSize->y)));
            			}
HXLINE( 262)			{
HXLINE( 262)				::Dynamic this7 = this->uvtData;
HXDLIN( 262)				::Dynamic this8 = this->uvtData;
HXDLIN( 262)				Float value5 = this->uvtData->get(1);
HXDLIN( 262)				Float value6 = this->vertices->get(5);
HXDLIN( 262)				Float value7 = (value6 - this->vertices->get(1));
HXDLIN( 262)				( ( ::openfl::_Vector::FloatVector)(this7) )->set(5,( ( ::openfl::_Vector::FloatVector)(this8) )->set(7,(value5 + (value7 / frame->sourceSize->y))));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTiledSprite_obj,updateVerticesData,(void))

Float FlxTiledSprite_obj::set_width(Float Width){
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_267_set_width)
HXLINE( 268)		if ((Width <= 0)) {
HXLINE( 269)			return Width;
            		}
HXLINE( 271)		if ((Width != this->get_width())) {
HXLINE( 272)			this->regen = true;
            		}
HXLINE( 274)		return this->super::set_width(Width);
            	}


Float FlxTiledSprite_obj::set_height(Float Height){
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_278_set_height)
HXLINE( 279)		if ((Height <= 0)) {
HXLINE( 280)			return Height;
            		}
HXLINE( 282)		if ((Height != this->get_height())) {
HXLINE( 283)			this->regen = true;
            		}
HXLINE( 285)		return this->super::set_height(Height);
            	}


Float FlxTiledSprite_obj::set_scrollX(Float Value){
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_289_set_scrollX)
HXLINE( 290)		if ((Value != this->scrollX)) {
HXLINE( 291)			this->regen = true;
            		}
HXLINE( 293)		return (this->scrollX = Value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTiledSprite_obj,set_scrollX,return )

Float FlxTiledSprite_obj::set_scrollY(Float Value){
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_297_set_scrollY)
HXLINE( 298)		if ((Value != this->scrollY)) {
HXLINE( 299)			this->regen = true;
            		}
HXLINE( 301)		return (this->scrollY = Value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTiledSprite_obj,set_scrollY,return )

bool FlxTiledSprite_obj::set_repeatX(bool Value){
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_305_set_repeatX)
HXLINE( 306)		if ((Value != this->repeatX)) {
HXLINE( 307)			this->regen = true;
            		}
HXLINE( 309)		return (this->repeatX = Value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTiledSprite_obj,set_repeatX,return )

bool FlxTiledSprite_obj::set_repeatY(bool Value){
            	HX_STACKFRAME(&_hx_pos_9c4135b7a1fcedcd_313_set_repeatY)
HXLINE( 314)		if ((Value != this->repeatY)) {
HXLINE( 315)			this->regen = true;
            		}
HXLINE( 317)		return (this->repeatY = Value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTiledSprite_obj,set_repeatY,return )


::hx::ObjectPtr< FlxTiledSprite_obj > FlxTiledSprite_obj::__new( ::Dynamic Graphic,Float Width,Float Height,::hx::Null< bool >  __o_RepeatX,::hx::Null< bool >  __o_RepeatY) {
	::hx::ObjectPtr< FlxTiledSprite_obj > __this = new FlxTiledSprite_obj();
	__this->__construct(Graphic,Width,Height,__o_RepeatX,__o_RepeatY);
	return __this;
}

::hx::ObjectPtr< FlxTiledSprite_obj > FlxTiledSprite_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic Graphic,Float Width,Float Height,::hx::Null< bool >  __o_RepeatX,::hx::Null< bool >  __o_RepeatY) {
	FlxTiledSprite_obj *__this = (FlxTiledSprite_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxTiledSprite_obj), true, "flixel.addons.display.FlxTiledSprite"));
	*(void **)__this = FlxTiledSprite_obj::_hx_vtable;
	__this->__construct(Graphic,Width,Height,__o_RepeatX,__o_RepeatY);
	return __this;
}

FlxTiledSprite_obj::FlxTiledSprite_obj()
{
}

void FlxTiledSprite_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxTiledSprite);
	HX_MARK_MEMBER_NAME(scrollX,"scrollX");
	HX_MARK_MEMBER_NAME(scrollY,"scrollY");
	HX_MARK_MEMBER_NAME(repeatX,"repeatX");
	HX_MARK_MEMBER_NAME(repeatY,"repeatY");
	HX_MARK_MEMBER_NAME(renderSprite,"renderSprite");
	HX_MARK_MEMBER_NAME(regen,"regen");
	HX_MARK_MEMBER_NAME(graphicVisible,"graphicVisible");
	 ::flixel::FlxStrip_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxTiledSprite_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(scrollX,"scrollX");
	HX_VISIT_MEMBER_NAME(scrollY,"scrollY");
	HX_VISIT_MEMBER_NAME(repeatX,"repeatX");
	HX_VISIT_MEMBER_NAME(repeatY,"repeatY");
	HX_VISIT_MEMBER_NAME(renderSprite,"renderSprite");
	HX_VISIT_MEMBER_NAME(regen,"regen");
	HX_VISIT_MEMBER_NAME(graphicVisible,"graphicVisible");
	 ::flixel::FlxStrip_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val FlxTiledSprite_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"regen") ) { return ::hx::Val( regen ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"scrollX") ) { return ::hx::Val( scrollX ); }
		if (HX_FIELD_EQ(inName,"scrollY") ) { return ::hx::Val( scrollY ); }
		if (HX_FIELD_EQ(inName,"repeatX") ) { return ::hx::Val( repeatX ); }
		if (HX_FIELD_EQ(inName,"repeatY") ) { return ::hx::Val( repeatY ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"loadFrame") ) { return ::hx::Val( loadFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_width") ) { return ::hx::Val( set_width_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"set_height") ) { return ::hx::Val( set_height_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"loadGraphic") ) { return ::hx::Val( loadGraphic_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_graphic") ) { return ::hx::Val( set_graphic_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_scrollX") ) { return ::hx::Val( set_scrollX_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_scrollY") ) { return ::hx::Val( set_scrollY_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_repeatX") ) { return ::hx::Val( set_repeatX_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_repeatY") ) { return ::hx::Val( set_repeatY_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"renderSprite") ) { return ::hx::Val( renderSprite ); }
		if (HX_FIELD_EQ(inName,"regenGraphic") ) { return ::hx::Val( regenGraphic_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"graphicVisible") ) { return ::hx::Val( graphicVisible ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"updateRenderSprite") ) { return ::hx::Val( updateRenderSprite_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateVerticesData") ) { return ::hx::Val( updateVerticesData_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val FlxTiledSprite_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"regen") ) { regen=inValue.Cast< bool >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"scrollX") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_scrollX(inValue.Cast< Float >()) );scrollX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"scrollY") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_scrollY(inValue.Cast< Float >()) );scrollY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"repeatX") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_repeatX(inValue.Cast< bool >()) );repeatX=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"repeatY") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_repeatY(inValue.Cast< bool >()) );repeatY=inValue.Cast< bool >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"renderSprite") ) { renderSprite=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"graphicVisible") ) { graphicVisible=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlxTiledSprite_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("scrollX",ab,33,d8,30));
	outFields->push(HX_("scrollY",ac,33,d8,30));
	outFields->push(HX_("repeatX",9d,d8,87,a6));
	outFields->push(HX_("repeatY",9e,d8,87,a6));
	outFields->push(HX_("renderSprite",fb,df,eb,32));
	outFields->push(HX_("regen",bd,2e,bf,e6));
	outFields->push(HX_("graphicVisible",aa,6a,88,e0));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxTiledSprite_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(FlxTiledSprite_obj,scrollX),HX_("scrollX",ab,33,d8,30)},
	{::hx::fsFloat,(int)offsetof(FlxTiledSprite_obj,scrollY),HX_("scrollY",ac,33,d8,30)},
	{::hx::fsBool,(int)offsetof(FlxTiledSprite_obj,repeatX),HX_("repeatX",9d,d8,87,a6)},
	{::hx::fsBool,(int)offsetof(FlxTiledSprite_obj,repeatY),HX_("repeatY",9e,d8,87,a6)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(FlxTiledSprite_obj,renderSprite),HX_("renderSprite",fb,df,eb,32)},
	{::hx::fsBool,(int)offsetof(FlxTiledSprite_obj,regen),HX_("regen",bd,2e,bf,e6)},
	{::hx::fsBool,(int)offsetof(FlxTiledSprite_obj,graphicVisible),HX_("graphicVisible",aa,6a,88,e0)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *FlxTiledSprite_obj_sStaticStorageInfo = 0;
#endif

static ::String FlxTiledSprite_obj_sMemberFields[] = {
	HX_("scrollX",ab,33,d8,30),
	HX_("scrollY",ac,33,d8,30),
	HX_("repeatX",9d,d8,87,a6),
	HX_("repeatY",9e,d8,87,a6),
	HX_("renderSprite",fb,df,eb,32),
	HX_("regen",bd,2e,bf,e6),
	HX_("graphicVisible",aa,6a,88,e0),
	HX_("destroy",fa,2c,86,24),
	HX_("loadGraphic",22,19,a5,44),
	HX_("loadFrame",27,c4,ba,21),
	HX_("set_graphic",cb,c1,6e,04),
	HX_("regenGraphic",6b,55,39,8b),
	HX_("draw",04,2c,70,42),
	HX_("updateRenderSprite",a4,1b,f9,aa),
	HX_("updateVerticesData",6c,6e,71,25),
	HX_("set_width",69,fe,5c,f1),
	HX_("set_height",24,16,51,f6),
	HX_("set_scrollX",ce,9a,3f,c1),
	HX_("set_scrollY",cf,9a,3f,c1),
	HX_("set_repeatX",c0,3f,ef,36),
	HX_("set_repeatY",c1,3f,ef,36),
	::String(null()) };

::hx::Class FlxTiledSprite_obj::__mClass;

void FlxTiledSprite_obj::__register()
{
	FlxTiledSprite_obj _hx_dummy;
	FlxTiledSprite_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.addons.display.FlxTiledSprite",1e,68,e9,6c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxTiledSprite_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxTiledSprite_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxTiledSprite_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxTiledSprite_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace addons
} // end namespace display
